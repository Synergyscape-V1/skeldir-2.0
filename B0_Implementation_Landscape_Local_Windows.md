# B0.1 - Contract Generation Infrastructure
- **Locations & entrypoints**: OpenAPI sources sit in `api-contracts/openapi/v1/` (core YAMLs plus `webhooks/{shopify,woocommerce,stripe,paypal}.yaml`). Primary bundling entrypoint is Bash `scripts/contracts/bundle.sh` (npx @redocly/cli; outputs to `api-contracts/dist/openapi/v1`) with `make contracts-check` and CI usage in `.github/workflows/contract-validation.yml` and `mock-contract-validation.yml`. Windows helper `scripts/contracts/validate-and-generate.ps1` only validates pre-bundled `api-contracts/dist/openapi/v1` and references a non-existent `scripts/generate-models.ps1`, so bundling still needs WSL/Git Bash.
- **Generated artifacts**: Bundled specs live in `api-contracts/dist/openapi/v1/*.bundled.yaml` (dated 2025-12-06) covering auth, attribution, reconciliation, export, health, llm-*, and four webhook vendors; `_common` copied alongside. No combined gateway spec present.
- **Contract to consumer linkage**: Mock scripts point Prism at source contracts (`scripts/start-mocks.sh`, `docker-compose.mock.yml` read `api-contracts/openapi/v1/...`). SDK generation script `scripts/generate-sdk.sh` targets `docs/api/contracts` (missing), so frontend linkage is stale; frontend already has generated clients in `frontend/src/api/generated/` with no current regenerate path.
- **CI guardrails**: `.github/workflows/contract-validation.yml` bundles then validates with openapi-generator and spectral and compares baselines via oasdiff; `.github/workflows/mock-contract-validation.yml` bundles then boots Prism mocks; `.github/workflows/contracts.yml` and `contract-enforcement.yml` also reference bundling/validation. Jobs run on Ubuntu; no Windows CI.
- **Status**:
  - Core contract generation scripts: implemented_and_tested (artifacts present; CI runs `scripts/contracts/bundle.sh`).
  - Per-vendor contract definitions: implemented_and_tested (`api-contracts/openapi/v1/webhooks/*.yaml` bundled to `dist/openapi/v1/webhooks.*.bundled.yaml`; validated in CI).
  - Combined/OpenAPI gateway spec: not_present (no aggregator spec in repo).
  - CI enforcement of contract freshness: implemented_and_tested (contract-validation/mock-contract-validation enforce bundling/validation; baselines checked in `contract-validation.yml`).

# B0.2 - Mock Server Orchestration
- **Tooling & topology**: Prism via process script `scripts/start-mocks.sh` or Docker `docker-compose.mock.yml`; legacy Mockoon runner `scripts/run-mocks.js` targets `mockoon/environments/*.json` for 5 services (no webhooks). Prism scripts bind ports 4010-4018 using raw contracts under `api-contracts/openapi/v1`.
- **Config & invocation (Windows)**: npm `mocks:start` and `scripts/start-mocks.sh` are Bash-only, so WSL/Git Bash needed; Docker compose works on Docker Desktop (`docker-compose -f docker-compose.mock.yml up`). Config is CLI flags (contract path + port); no env indirection; no PowerShell wrapper.
- **Contract alignment**: Prism maps contracts explicitly (e.g., `api-contracts/openapi/v1/webhooks/shopify.yaml` -> port 4015 per `scripts/start-mocks.sh` and `docker-compose.mock.yml`). `scripts/contracts/mock_registry.json` lists extra LLM mocks on ports 4024-4026, but `start-mocks.sh`/compose never start them, and Mockoon runner omits webhook mocks, leaving registry and CI curl probes (`mock-contract-validation.yml` curls 4024-4026) inconsistent with running services.
- **CI / automation**: `.github/workflows/mock-contract-validation.yml` bundles contracts then calls `scripts/start-mocks.sh` on Ubuntu; curl probes are best-effort (`|| echo`, so failures do not fail the job). No backend tests hit mocks in CI; outside that workflow behavior is local-only.
- **Status**:
  - Mock server tool installation and configuration: implemented_not_tested (scripts exist; Windows requires WSL/Docker; CI smoke does not fail on missing ports).
  - Per-vendor mock routes: implemented_not_tested (Prism configs for Shopify/Stripe/WooCommerce/PayPal in `scripts/start-mocks.sh` and `docker-compose.mock.yml`; Mockoon path missing vendors).
  - Contract-driven mocking: implemented_not_tested (Prism uses contracts; Mockoon uses static JSON; LLM mocks not wired).
  - CI integration: implemented_not_tested (mock-contract-validation runs but tolerates missing ports/LLM mocks).

# B0.3 - Database Schema & RLS
- **Migrations & entrypoints**: Alembic migrations under `alembic/versions` (core schema `001_core_schema/...`, PII controls `002_pii_controls`, data governance `003_data_governance`, etc.). Canonical snapshot at `db/schema/canonical_schema.sql`. Apply via `alembic upgrade head` (per `backend/README.md`) using `DATABASE_URL` for Neon or local Postgres.
- **Core tables & roles**: `202511131115_add_core_tables.py` creates `tenants`, `attribution_events`, `dead_events`, `attribution_allocations`, `revenue_ledger`, `reconciliation_runs`; `202511151400_add_tenants_auth_columns.py` adds `api_key_hash`/`notification_email`; `202511151410_realign_attribution_events.py` adds idempotency_key/event_type/channel/processing_status/etc.; `202511171000_add_webhook_secrets.py` adds vendor secrets. GRANTs only cover `app_rw`/`app_ro` (`202511131121_add_grants.py`); no migration creates `app_user` (role referenced only in docs/tests).
- **RLS policies**: `202511131120_add_rls_policies.py` enables and forces RLS on attribution_events, dead_events, attribution_allocations, revenue_ledger, reconciliation_runs using `tenant_id = current_setting('app.current_tenant_id')::uuid`; canonical snapshot matches. Channel taxonomy is reference data without RLS; GRANTs rely on RLS for isolation.
- **Empirical RLS check (run locally)**: `python backend/test_rls_direct.py` (DSN `postgresql://app_user:...@ep-lucky-base.../neondb`) inserted tenant A/B and one event, then read as each tenant. Output: tenant B read returned `None`; tenant A read returned the event (RLS enforced).
- **Status**:
  - Migrations reflect described schema: implemented_not_tested (present but not applied locally this session).
  - `app_user` role exists and is used by the app: implemented_not_tested (not provisioned by migrations; manual Neon role worked for `backend/test_rls_direct.py`).
  - RLS enabled on all tenant-sensitive tables: implemented_and_tested (policies in migrations; readiness endpoint checks `relrowsecurity`; empirical script observed enforcement).
  - Empirical RLS isolation validated locally: implemented_and_tested (command `python backend/test_rls_direct.py` on 2025-12-11 blocked cross-tenant read).

# B0.4 - Ingestion Service & Observability
- **Service location & startup**: FastAPI app `backend/app/main.py` wires routers under `/api`. Start on Windows via `cd backend && uvicorn app.main:app --host 0.0.0.0 --port 8000` with `.env`/`DATABASE_URL` (asyncpg). Middleware includes PII stripping (`backend/app/middleware/pii_stripping.py`) and correlation propagation (`backend/app/middleware/observability.py`).
- **Webhook endpoints**: `backend/app/api/webhooks.py` defines POST routes `/api/webhooks/shopify/order_create`, `/api/webhooks/stripe/payment_intent_succeeded`, `/api/webhooks/paypal/sale_completed`, `/api/webhooks/woocommerce/order_completed`; request models in `backend/app/schemas/webhooks_{shopify,stripe,paypal,woocommerce}.py`; HMAC helpers in `backend/app/webhooks/signatures.py`; tenant resolution via `X-Skeldir-Tenant-Key` to `app/core/tenant_context.py`.
- **Idempotent ingestion & DLQ**: `backend/app/ingestion/event_service.py` enforces idempotency via lookup on `idempotency_key` and UNIQUE column added by `202511151410_realign_attribution_events.py`; dead-letter routing via `DLQHandler.route_to_dlq` (`backend/app/ingestion/dlq_handler.py`). Channel normalization consumes `db/channel_mapping.yaml` through `backend/app/ingestion/channel_normalization.py`. DB sessions set `app.current_tenant_id` in `backend/app/db/session.py`.
- **Observability**: Structured JSON logging configured in `backend/app/observability/logging_config.py` using context vars from `backend/app/observability/context.py`; middleware echoes `X-Correlation-ID`. Metrics counters/histogram in `backend/app/observability/metrics.py`; exposed at `/metrics` in `backend/app/api/health.py` alongside readiness check that validates DB connectivity and the tenant GUC.
- **Tests & coverage**: Ingestion/idempotency/channel/DLQ in `backend/tests/test_b043_ingestion.py`; DLQ handler in `backend/tests/test_b044_dlq_handler.py`; webhook success/invalid signature/idempotency in `backend/tests/test_b045_webhooks.py`; logging/metrics contract in `backend/tests/test_b047_logging_and_metrics_contract.py` (app_user DSN). RLS E2E template `backend/tests/test_rls_e2e.py` is stubbed. `scripts/measure-latency.sh` exists but is not tied to automated tests.
- **Status**:
  - All four webhook endpoints present and wired: implemented_and_tested (routes/schemas plus CI tests in `backend/tests/test_b045_webhooks.py`; not rerun locally this session).
  - HMAC validation implemented and covered by tests: implemented_and_tested (`backend/app/webhooks/signatures.py`; negative/positive cases in `backend/tests/test_b045_webhooks.py`).
  - Idempotent ingestion implemented: implemented_not_tested (logic in `backend/app/ingestion/event_service.py` and idempotency column; CI covers via `test_b043_ingestion.py`, not rerun locally).
  - DLQ path implemented and tested: implemented_not_tested (`backend/app/ingestion/dlq_handler.py`; exercised by `test_b044_dlq_handler.py` and `test_b047_logging_and_metrics_contract.py`, not rerun locally).
  - Structured logging with tenant and correlation IDs: implemented_and_tested (middleware + logging_config; asserted in `test_b047_logging_and_metrics_contract.py`).
  - Metrics wired and exposed: implemented_and_tested (`/metrics` endpoint; metrics assertions in `test_b047_logging_and_metrics_contract.py`).
  - Integration tests passing locally under app_user: unclear_from_codebase (tests rely on remote Neon DSN; not executed here beyond the RLS script).

# Cross-Cutting Observations (CI, Windows-specific)
- **CI vs local parity**: Contract CI uses `api-contracts` toolchain while legacy `contracts/` paths remain in `.github/workflows/ci.yml`, so sources diverge. Mock CI starts Prism but does not fail on missing LLM/mock ports. Backend CI job (`ci.yml` test-backend) runs `pytest` without DB provisioning, assuming Neon access; local Windows runs need a working `DATABASE_URL`. Local empirical RLS script succeeded against Neon `app_user`.
- **Windows friction**: Most tooling is Bash-first; `scripts/contracts/validate-and-generate.ps1` cannot bundle and calls a missing `generate-models.ps1`. Prism mocks, contract bundling, and Make targets need WSL/Git Bash; Docker compose needs Docker Desktop. Starting FastAPI requires asyncpg-capable Python and SSL-friendly `DATABASE_URL`. Running DB or mock-dependent tests locally will hit the shared Neon database unless a local Postgres is stood up.
