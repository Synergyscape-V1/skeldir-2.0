# B0.4 Local Codebase Context Report – Backend Engineer

## 1. Environment and Connection Snapshot
- Git branch `main`, head commit `1e2f0c37dd292b281b4083ad0d2063eef16f8296`.
- Settings live in `backend/app/core/config.py` using Pydantic `Settings` (env file `.env` at repo root). `.env` currently points `DATABASE_URL` to the Neon `neondb_owner` role (sslmode=require, channel_binding=require) and sets tenant header `X-Skeldir-Tenant-Key`.
- Async session factory: `backend/app/db/session.py` builds an asyncpg engine, exposes `AsyncSessionLocal` and `get_session(tenant_id)` which executes `select set_config('app.current_tenant_id', :tenant_id, false)` before yielding.
- RLS check executed via ad-hoc script (`PYTHONPATH=backend` + `app.db.session.get_session`) reading `current_setting('app.current_tenant_id', true)`; using an existing tenant the value returned the expected UUID. Command used: `python - <<SCRIPT ... get_session(...).execute("select current_setting('app.current_tenant_id', true)") ... SCRIPT`.

## 2. Webhook Infrastructure Inventory
- Pydantic webhook models exist but are unused by any router:
  - Shopify models in `backend/app/schemas/webhooks_shopify.py` (`ShopifyOrderCreateRequest`, `ShopifyOrderPaidRequest`, `ShopifyRefundCreateRequest`, `WebhookAcknowledgement`, `Problem`).
  - Stripe models in `backend/app/schemas/webhooks_stripe.py` (`StripeChargeSucceededRequest`, `StripeChargeRefundedRequest`, `StripePaymentIntentSucceededRequest`, `WebhookAcknowledgement`, `Problem`).
  - PayPal models in `backend/app/schemas/webhooks_paypal.py` (`PayPalSaleCompletedRequest`, `PayPalSaleRefundedRequest`, shared amount enums, `WebhookAcknowledgement`, `Problem`).
  - WooCommerce models in `backend/app/schemas/webhooks_woocommerce.py` (`WooCommerceOrderCreatedRequest`, `WooCommerceOrderCompletedRequest`, `WooCommerceOrderRefundedRequest`, `WebhookAcknowledgement`, `Problem`).
- No webhook routers are registered. `backend/app/main.py` only includes `app.api.auth` and `app.api.attribution`; there is no `/api/webhooks/...` router module.
- Middleware stack in `backend/app/main.py`: `PIIStrippingMiddleware` then `CORSMiddleware`. No tenant-context middleware, logging/tracing middleware, or signature verification middleware is installed.

## 3. Ingestion and Dead-Letter Integration
- Ingestion service: `backend/app/ingestion/event_service.py` defines `EventIngestionService.ingest_event(session, tenant_id, event_data, idempotency_key, source="webhook")` and the helper `ingest_with_transaction(tenant_id, event_data, idempotency_key, source="webhook")`.
  - Validates required fields (`event_type`, `event_timestamp`, `revenue_amount`, `session_id`), converts revenue to cents, normalizes channel via `ingestion.channel_normalization.normalize_channel`, and populates `AttributionEvent`. Duplicate detection is via `_check_duplicate` on `idempotency_key` (model has a global UNIQUE on `idempotency_key`).
  - On `ValidationError`, it calls `_route_to_dlq` which forwards to `DLQHandler.route_to_dlq` then re-raises.
- DLQ handler: `backend/app/ingestion/dlq_handler.py` exposes `route_to_dlq(session, tenant_id, original_payload, error, correlation_id, source)` and `retry_dead_event(session, dead_event_id, force_retry=False)`. Classifies errors, writes `DeadEvent` with `error_type/error_code/error_detail`, tracks retries/backoff, and updates remediation status.
- Route-to-ingestion mapping: no FastAPI routes currently invoke `EventIngestionService` or `ingest_with_transaction`; ingestion is only exercised in tests and ad-hoc scripts.
- RLS usage during ingestion/DLQ: code assumes callers pass a `get_session` session so tenant context is set. Empirical cross-tenant check using owner DSN showed RLS bypass:
  - Script created two tenants, ingested an event for tenant A via `EventIngestionService` using `get_session(tenant_a)`, then queried with `get_session(tenant_b)`.
  - Result: tenant B could read tenant A’s event (output `Tenant B sees: <AttributionEvent(...tenant_a...)>`), while `pg_class` reports `relrowsecurity=TRUE`/`relforcerowsecurity=TRUE`. Likely cause: using the superuser/owner connection from `.env` bypasses RLS. Tests use `app_user` (see `backend/tests/conftest.py`) which should honor RLS.

## 4. PII Stripping and Tenant Context Pipeline
- PII stripping:
  - Middleware `backend/app/middleware/pii_stripping.py` redacts values for keys such as `email`, `phone`, `address`, `ip`, `ssn`, `credit_card`, `passport`, `billing_address`, `shipping_address`, `customer_email`, `customer_phone` for JSON bodies on POST/PUT/PATCH before hitting route handlers.
  - Database Layer 2 guardrails from migrations (`alembic/versions/002_pii_controls/202511161200_add_pii_guardrail_triggers.py`) add BEFORE INSERT triggers on `attribution_events.raw_payload`, `dead_events.raw_payload`, and `revenue_ledger.metadata` to reject payloads containing PII keys (key-based detection).
- Tenant context resolution:
  - Helpers in `backend/app/core/tenant_context.py`: `derive_tenant_id_from_request` (prefers `request.state.auth_context.tenant_id`, otherwise looks up API key), `get_tenant_id_from_api_key` (hashes API key, queries `tenants.api_key_hash` **and tenants.state='active'`, but the `state` column does not exist in the current `tenants` table), and `tenant_context_middleware` which sets `app.current_tenant_id` on a request-scoped session.
  - These helpers are not wired into `FastAPI` (`tenant_context_middleware` is never added, and no dependency populates `request.state.db_session`), so tenant resolution is currently unused by the running app.
- Empirical tenant lookup check: not performed via HTTP; API-key lookup would currently 500/raise because of the missing `state` column.

## 5. Signature and HMAC Verification Per Vendor
- No signature/HMAC verification utilities or middleware exist in the codebase. `rg` finds no references to HMAC or vendor-specific signature headers.
- Secrets for Shopify/Stripe/PayPal/WooCommerce signatures are not present in settings or `.env`.
- Because there are no webhook routes, no verification is performed at any point in the request lifecycle.

## 6. Webhook Route Coverage and Gaps
- Intended flows inferred from Pydantic models:
  - Shopify: order create, order paid, refund create models exist; no `/api/webhooks/shopify/...` routes, no ingestion calls, no tenant/PII/signature handling, and no tests hitting such routes.
  - Stripe: charge.succeeded, charge.refunded, payment_intent.succeeded models exist; no routes or handlers; no signature enforcement (e.g., `Stripe-Signature`), no ingestion wiring, no tests beyond model import sanity.
  - PayPal: sale completed and sale refunded models exist; no routes; no signature or ingestion wiring.
  - WooCommerce: order created/completed/refunded models exist; no routes; no signature or ingestion wiring.
- Existing FastAPI routes are limited to auth and attribution revenue stub; none interface with the ingestion/DLQ path.
- Tests referencing webhooks: only `backend/tests/test_generated_models.py` asserts the existence of the generated `WebhookAcknowledgement` model; no end-to-end webhook tests exist.

## 7. Observed Risks, Constraints, and Questions
- RLS bypass risk: using the `neondb_owner` DSN from `.env` allows cross-tenant reads despite policies; switching to the least-privileged `app_user` (as used in tests) is necessary to exercise RLS correctly.
- Tenant API key resolution is broken against the current schema: `derive_tenant_id_from_request` → `get_tenant_id_from_api_key` queries a non-existent `tenants.state` column; any API-key-based call would error.
- Webhook ingress is entirely missing: no FastAPI routers for Shopify/Stripe/PayPal/WooCommerce, no signature verification, no mapping to `EventIngestionService`, and no DLQ integration at the HTTP edge.
- Tenant context middleware is defined but not installed; request handling today never sets `app.current_tenant_id`, so any future DB usage from routes would default to unset tenant context (or rely on manual `get_session` usage).
- Idempotency is enforced globally via UNIQUE(idempotency_key) on `attribution_events`, not scoped by tenant; with RLS enabled this surfaces as cross-tenant unique conflicts.
- PII defense relies on middleware key-based redaction plus DB key-based triggers; value-based PII (e.g., emails in free-text fields) is not blocked and should be covered by additional scanning/testing.
