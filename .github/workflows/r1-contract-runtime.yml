# R1 Contract/Runtime Viability Validation
#
# Mission: Prove the system is invokable end-to-end at runtime (no "it compiles" illusions)
# by converting contracts into live, DB-backed, log-verifiable behavior.
#
# Exit Gates (all must PASS for R1 COMPLETE):
# - EG-R1-0: Evidence Anchor & Provenance
# - EG-R1-1: Strict OpenAPI Validation + Smoke Codegen
# - EG-R1-2: Prism Mock Boot + Sample Requests (prerequisite only)
# - EG-R1-3: Fresh DB Schema Apply (Zero → Head) + Idempotency
# - EG-R1-4: Live Stack Boot + /health and /metrics
# - EG-R1-5: Live Endpoint Contract Enforcement + Postgres Interaction (CLOSURE GATE)
#
# Critical: EG-R1-5 is the closure gate. Mock success alone does not complete R1.

name: "R1: Contract/Runtime Viability"

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - 'api-contracts/**'
      - 'backend/**'
      - 'db/**'
      - 'scripts/contracts/**'
      - '.github/workflows/r1-contract-runtime.yml'

env:
  POSTGRES_USER: skeldir_test
  POSTGRES_PASSWORD: skeldir_test_password
  POSTGRES_DB: skeldir_test
  POSTGRES_DIGEST: postgres@sha256:b3968e348b48f1198cc6de6611d055dbad91cd561b7990c406c3fc28d7095b21

jobs:
  r1-validation:
    name: "R1 Contract/Runtime Viability"
    runs-on: ubuntu-22.04

    env:
      ARTIFACTS_DIR: ${{ github.workspace }}/artifacts/runtime_r1/${{ github.sha }}

    steps:
      - name: "Checkout repository (immutable ref)"
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1 pinned by SHA
        with:
          fetch-depth: 0

      # ====================================================================
      # EG-R1-0: Evidence Anchor & Provenance
      # ====================================================================
      - name: "EG-R1-0: Capture evidence anchor and provenance"
        run: |
          echo "=== EG-R1-0: Evidence Anchor & Provenance ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR"

          # Capture candidate SHA and tree status
          CANDIDATE_SHA=$(git rev-parse HEAD)
          TREE_STATUS=$(git status --porcelain | wc -l)

          echo "**Candidate SHA:** \`$CANDIDATE_SHA\`" | tee -a $GITHUB_STEP_SUMMARY
          echo "**Modified files:** $TREE_STATUS" | tee -a $GITHUB_STEP_SUMMARY

          if [ "$TREE_STATUS" -gt 0 ]; then
            echo "⚠️ Tree is dirty (files modified)" | tee -a $GITHUB_STEP_SUMMARY
            git status --porcelain | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "✅ Tree is clean" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Capture environment snapshot
          cat > "$ARTIFACTS_DIR/ENV_SNAPSHOT.json" <<EOF
          {
            "candidate_sha": "$CANDIDATE_SHA",
            "run_id": "${{ github.run_id }}",
            "run_attempt": "${{ github.run_attempt }}",
            "captured_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "operator_id": "github-actions",
            "substrate": "ubuntu-22.04",
            "os_version": "$(cat /etc/os-release | grep VERSION= | cut -d'=' -f2 | tr -d '\"')",
            "kernel": "$(uname -r)",
            "docker_version": "$(docker --version | awk '{print $3}' | tr -d ',')",
            "node_version": "$(node --version)",
            "python_version": "$(python3 --version | awk '{print $2}')"
          }
          EOF

          cat "$ARTIFACTS_DIR/ENV_SNAPSHOT.json" | tee -a $GITHUB_STEP_SUMMARY

          # Initialize command log
          echo "=== R1 Command Log ===" > "$ARTIFACTS_DIR/COMMAND_LOG.txt"
          echo "Started: $(date -u)" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"
          echo "Candidate SHA: $CANDIDATE_SHA" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"
          echo "" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

          echo "✅ **EG-R1-0 PASS:** Evidence anchor captured" | tee -a $GITHUB_STEP_SUMMARY

      # ====================================================================
      # EG-R1-1: Strict OpenAPI Validation + Smoke Codegen
      # ====================================================================
      - name: "Setup Node.js for contract validation"
        uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8  # v4.0.2 pinned by SHA
        with:
          node-version: '20'
          cache: 'npm'

      - name: "Install contract validation dependencies"
        run: |
          npm ci
          echo "npm ci" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

      - name: "Setup Python for model generation"
        uses: actions/setup-python@82c7e631bb3cdc910f68e0081d67478d79c6982d  # v5.1.0 pinned by SHA
        with:
          python-version: '3.11.9'

      - name: "Install Python dependencies for codegen"
        run: |
          pip install datamodel-code-generator pyyaml
          echo "pip install datamodel-code-generator pyyaml" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

      - name: "EG-R1-1: OpenAPI validation + smoke codegen"
        run: |
          set -o pipefail  # Ensure pipeline exit code reflects script failures
          echo "=== EG-R1-1: Strict OpenAPI Validation + Smoke Codegen ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR/CONTRACTS"

          # Run contract validation pipeline
          echo "Running: bash scripts/contracts/check.sh smoke" | tee -a "$ARTIFACTS_DIR/COMMAND_LOG.txt"

          if bash scripts/contracts/check.sh smoke 2>&1 | tee "$ARTIFACTS_DIR/CONTRACTS/openapi_contracts_check.log"; then
            echo "✅ Contract validation PASSED" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "❌ Contract validation FAILED" | tee -a $GITHUB_STEP_SUMMARY
            echo "FAIL" > "$ARTIFACTS_DIR/CONTRACTS/verdict.txt"
            exit 1
          fi

          # Capture bundled spec tree hash
          if [ -d "api-contracts/dist/openapi/v1" ]; then
            find api-contracts/dist/openapi/v1 -name "*.yaml" -o -name "*.yml" | sort | xargs sha256sum > "$ARTIFACTS_DIR/CONTRACTS/bundled_spec_tree_hash.txt"
            BUNDLE_HASH=$(cat "$ARTIFACTS_DIR/CONTRACTS/bundled_spec_tree_hash.txt" | sha256sum | cut -d' ' -f1)
            echo "**Bundled spec tree hash:** \`$BUNDLE_HASH\`" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Bundled spec directory not found" | tee -a $GITHUB_STEP_SUMMARY
          fi

          echo "PASS" > "$ARTIFACTS_DIR/CONTRACTS/verdict.txt"
          echo "✅ **EG-R1-1 PASS:** OpenAPI validation + smoke codegen successful" | tee -a $GITHUB_STEP_SUMMARY

      # ====================================================================
      # EG-R1-3: Fresh DB Schema Apply (Zero → Head) + Idempotency
      # ====================================================================
      - name: "Create isolated Docker network for R1"
        run: |
          docker network create --internal skeldir-r1-isolated || true
          echo "docker network create --internal skeldir-r1-isolated" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

      - name: "EG-R1-3: Fresh DB schema apply + idempotency test"
        run: |
          echo "=== EG-R1-3: Fresh DB Schema Apply (Zero → Head) ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR/DB_SCHEMA"

          # Start fresh Postgres instance
          docker run -d \
            --name skeldir-r1-postgres \
            --network skeldir-r1-isolated \
            -e POSTGRES_USER=$POSTGRES_USER \
            -e POSTGRES_PASSWORD=$POSTGRES_PASSWORD \
            -e POSTGRES_DB=$POSTGRES_DB \
            -p 5432:5432 \
            $POSTGRES_DIGEST

          echo "docker run postgres (digest pinned)" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

          # Wait for Postgres to be ready
          echo "Waiting for Postgres to be ready..."
          for i in {1..30}; do
            if docker exec skeldir-r1-postgres pg_isready -U $POSTGRES_USER; then
              echo "Postgres is ready after $i seconds"
              break
            fi
            sleep 1
          done

          # Apply canonical schema (Run 1)
          echo "Applying canonical schema (Run 1)..." | tee -a $GITHUB_STEP_SUMMARY
          if docker exec -i skeldir-r1-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB < db/schema/canonical_schema.sql 2>&1 | tee "$ARTIFACTS_DIR/DB_SCHEMA/schema_apply_run1.log"; then
            echo "✅ Schema apply Run 1 succeeded" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Schema apply Run 1 had warnings (may be expected for CREATE IF NOT EXISTS)" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Capture schema state after Run 1
          docker exec skeldir-r1-postgres pg_dump --schema-only --no-owner --no-privileges -U $POSTGRES_USER $POSTGRES_DB > "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run1.sql"
          SCHEMA_HASH_RUN1=$(sha256sum "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run1.sql" | cut -d' ' -f1)
          echo "**Schema hash after Run 1:** \`$SCHEMA_HASH_RUN1\`" | tee -a $GITHUB_STEP_SUMMARY

          # Apply canonical schema again (Run 2 - idempotency test)
          echo "Applying canonical schema (Run 2 - idempotency)..." | tee -a $GITHUB_STEP_SUMMARY
          if docker exec -i skeldir-r1-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB < db/schema/canonical_schema.sql 2>&1 | tee "$ARTIFACTS_DIR/DB_SCHEMA/schema_apply_run2.log"; then
            echo "✅ Schema apply Run 2 succeeded" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Schema apply Run 2 had warnings" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Capture schema state after Run 2
          docker exec skeldir-r1-postgres pg_dump --schema-only --no-owner --no-privileges -U $POSTGRES_USER $POSTGRES_DB > "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run2.sql"
          SCHEMA_HASH_RUN2=$(sha256sum "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run2.sql" | cut -d' ' -f1)
          echo "**Schema hash after Run 2:** \`$SCHEMA_HASH_RUN2\`" | tee -a $GITHUB_STEP_SUMMARY

          # Compare hashes for idempotency
          if [ "$SCHEMA_HASH_RUN1" = "$SCHEMA_HASH_RUN2" ]; then
            echo "✅ **Schema is idempotent:** Run1 == Run2" | tee -a $GITHUB_STEP_SUMMARY
            echo "PASS" > "$ARTIFACTS_DIR/DB_SCHEMA/verdict.txt"
          else
            echo "❌ **Schema drift detected:** Run1 != Run2" | tee -a $GITHUB_STEP_SUMMARY
            diff "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run1.sql" "$ARTIFACTS_DIR/DB_SCHEMA/schema_after_run2.sql" | head -30 | tee -a $GITHUB_STEP_SUMMARY
            echo "FAIL" > "$ARTIFACTS_DIR/DB_SCHEMA/verdict.txt"
          fi

          # Verify RLS is enabled on attribution_events
          echo "Verifying RLS configuration..." | tee -a $GITHUB_STEP_SUMMARY
          RLS_CHECK=$(docker exec skeldir-r1-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SELECT relrowsecurity, relforcerowsecurity FROM pg_class WHERE relname = 'attribution_events';" 2>/dev/null || echo "table_not_found")
          echo "**RLS status for attribution_events:** $RLS_CHECK" | tee -a $GITHUB_STEP_SUMMARY

          echo "✅ **EG-R1-3 PASS:** Schema applied and idempotency verified" | tee -a $GITHUB_STEP_SUMMARY

      # ====================================================================
      # EG-R1-4: Live Stack Boot + /health and /metrics
      # ====================================================================
      - name: "Install backend dependencies"
        run: |
          cd backend
          pip install -r requirements-lock.txt
          # email-validator is required for Pydantic EmailStr validation
          pip install email-validator
          echo "pip install -r backend/requirements-lock.txt email-validator" >> "$ARTIFACTS_DIR/COMMAND_LOG.txt"

      - name: "EG-R1-4: Live stack boot + health/metrics probes"
        run: |
          echo "=== EG-R1-4: Live Stack Boot + /health and /metrics ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR/LIVE_STACK"

          # Configure database connection for backend
          export DATABASE_URL="postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@localhost:5432/$POSTGRES_DB"
          export ENVIRONMENT="test"
          export LOG_LEVEL="INFO"

          # Start FastAPI backend with uvicorn
          echo "Starting FastAPI backend..." | tee -a $GITHUB_STEP_SUMMARY
          cd backend
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &
          BACKEND_PID=$!
          echo $BACKEND_PID > /tmp/backend.pid
          cd ..

          echo "Backend PID: $BACKEND_PID" | tee -a "$ARTIFACTS_DIR/COMMAND_LOG.txt"

          # Wait for backend to be ready
          echo "Waiting for backend to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "Backend is ready after $i seconds"
              break
            fi
            sleep 1
          done

          # Probe /health endpoint
          echo "Probing /health endpoint..." | tee -a $GITHUB_STEP_SUMMARY
          HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/health)
          HEALTH_BODY=$(echo "$HEALTH_RESPONSE" | head -n -1)
          HEALTH_CODE=$(echo "$HEALTH_RESPONSE" | tail -n 1)

          echo "**Health endpoint response:**" | tee -a $GITHUB_STEP_SUMMARY
          echo "Status: $HEALTH_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $HEALTH_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "$HEALTH_BODY" > "$ARTIFACTS_DIR/LIVE_STACK/curl_live_health.log"

          if [ "$HEALTH_CODE" = "200" ]; then
            echo "✅ /health returned 200" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "❌ /health returned $HEALTH_CODE (expected 200)" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Probe /metrics endpoint
          echo "Probing /metrics endpoint..." | tee -a $GITHUB_STEP_SUMMARY
          METRICS_RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/metrics)
          METRICS_BODY=$(echo "$METRICS_RESPONSE" | head -n -1)
          METRICS_CODE=$(echo "$METRICS_RESPONSE" | tail -n 1)

          echo "**Metrics endpoint status:** $METRICS_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "$METRICS_BODY" | head -20 > "$ARTIFACTS_DIR/LIVE_STACK/curl_live_metrics.log"

          if [ "$METRICS_CODE" = "200" ]; then
            echo "✅ /metrics returned 200" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "❌ /metrics returned $METRICS_CODE (expected 200)" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Capture backend logs
          echo "Backend is running on PID $BACKEND_PID" > "$ARTIFACTS_DIR/LIVE_STACK/live_stack_boot.log"

          if [ "$HEALTH_CODE" = "200" ] && [ "$METRICS_CODE" = "200" ]; then
            echo "PASS" > "$ARTIFACTS_DIR/LIVE_STACK/verdict.txt"
            echo "✅ **EG-R1-4 PASS:** Live stack boots, /health and /metrics return 200" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "FAIL" > "$ARTIFACTS_DIR/LIVE_STACK/verdict.txt"
            echo "❌ **EG-R1-4 FAIL:** Health or metrics endpoint failed" | tee -a $GITHUB_STEP_SUMMARY
          fi

      # ====================================================================
      # EG-R1-5: Live Endpoint Contract Enforcement + Postgres Interaction (CLOSURE)
      # ====================================================================
      - name: "EG-R1-5: Live contract enforcement + DB interaction (CLOSURE GATE)"
        run: |
          echo "=== EG-R1-5: Live Contract Enforcement + Postgres Interaction (CLOSURE) ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT"

          # Configure database connection
          export DATABASE_URL="postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@localhost:5432/$POSTGRES_DB"

          echo "### Endpoint Selection" | tee -a $GITHUB_STEP_SUMMARY
          echo "**READ endpoint:** GET /api/attribution/revenue/realtime" | tee -a $GITHUB_STEP_SUMMARY
          echo "**WRITE endpoint:** POST /api/auth/login" | tee -a $GITHUB_STEP_SUMMARY
          echo "" | tee -a $GITHUB_STEP_SUMMARY

          # ===== READ ENDPOINT: GET /api/attribution/revenue/realtime =====
          echo "### READ Endpoint: GET /api/attribution/revenue/realtime" | tee -a $GITHUB_STEP_SUMMARY

          # Happy path
          echo "**Happy path (valid request):**" | tee -a $GITHUB_STEP_SUMMARY
          CORR_ID=$(uuidgen)
          READ_HAPPY=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer test_token" \
            -H "X-Correlation-ID: $CORR_ID" \
            http://localhost:8000/api/attribution/revenue/realtime)
          READ_HAPPY_BODY=$(echo "$READ_HAPPY" | head -n -1)
          READ_HAPPY_CODE=$(echo "$READ_HAPPY" | tail -n 1)

          echo "Status: $READ_HAPPY_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $READ_HAPPY_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "Correlation-ID: $CORR_ID" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"
          echo "Response: $READ_HAPPY_BODY" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"
          echo "Status: $READ_HAPPY_CODE" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"

          # Invalid path (missing required header)
          echo "**Invalid path (missing X-Correlation-ID):**" | tee -a $GITHUB_STEP_SUMMARY
          READ_INVALID=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: Bearer test_token" \
            http://localhost:8000/api/attribution/revenue/realtime)
          READ_INVALID_BODY=$(echo "$READ_INVALID" | head -n -1)
          READ_INVALID_CODE=$(echo "$READ_INVALID" | tail -n 1)

          echo "Status: $READ_INVALID_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $READ_INVALID_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "Response: $READ_INVALID_BODY" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_invalid_payload.log"
          echo "Status: $READ_INVALID_CODE" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_invalid_payload.log"

          # ===== WRITE ENDPOINT: POST /api/auth/login =====
          echo "### WRITE Endpoint: POST /api/auth/login" | tee -a $GITHUB_STEP_SUMMARY

          # Happy path
          echo "**Happy path (valid login):**" | tee -a $GITHUB_STEP_SUMMARY
          CORR_ID=$(uuidgen)
          WRITE_HAPPY=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "X-Correlation-ID: $CORR_ID" \
            -d '{"email":"test@example.com","password":"testpassword123"}' \
            http://localhost:8000/api/auth/login)
          WRITE_HAPPY_BODY=$(echo "$WRITE_HAPPY" | head -n -1)
          WRITE_HAPPY_CODE=$(echo "$WRITE_HAPPY" | tail -n 1)

          echo "Status: $WRITE_HAPPY_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $WRITE_HAPPY_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "Correlation-ID: $CORR_ID" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"
          echo "Login Response: $WRITE_HAPPY_BODY" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"
          echo "Login Status: $WRITE_HAPPY_CODE" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_happy_path.log"

          # Invalid path (invalid JSON)
          echo "**Invalid path (malformed JSON):**" | tee -a $GITHUB_STEP_SUMMARY
          WRITE_INVALID=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "X-Correlation-ID: $(uuidgen)" \
            -d '{invalid json}' \
            http://localhost:8000/api/auth/login)
          WRITE_INVALID_BODY=$(echo "$WRITE_INVALID" | head -n -1)
          WRITE_INVALID_CODE=$(echo "$WRITE_INVALID" | tail -n 1)

          echo "Status: $WRITE_INVALID_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $WRITE_INVALID_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "Invalid JSON Response: $WRITE_INVALID_BODY" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_invalid_payload.log"
          echo "Invalid JSON Status: $WRITE_INVALID_CODE" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/curl_live_invalid_payload.log"

          # ===== DB INTERACTION PROOF =====
          echo "### Postgres Interaction Proof" | tee -a $GITHUB_STEP_SUMMARY

          # Query DB to prove tables exist and RLS is configured
          DB_PROOF=$(docker exec skeldir-r1-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -c "
            SELECT table_name,
                   (SELECT relrowsecurity FROM pg_class WHERE relname = table_name LIMIT 1) as rls_enabled
            FROM information_schema.tables
            WHERE table_schema = 'public'
            AND table_type = 'BASE TABLE'
            ORDER BY table_name;
          " 2>&1)

          echo "**Database tables with RLS status:**" | tee -a $GITHUB_STEP_SUMMARY
          echo "\`\`\`" | tee -a $GITHUB_STEP_SUMMARY
          echo "$DB_PROOF" | tee -a $GITHUB_STEP_SUMMARY
          echo "\`\`\`" | tee -a $GITHUB_STEP_SUMMARY
          echo "$DB_PROOF" > "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/db_probe_before_after.log"

          # Check if readiness endpoint touches DB
          echo "**Readiness endpoint (DB health check):**" | tee -a $GITHUB_STEP_SUMMARY
          READY_RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:8000/health/ready)
          READY_BODY=$(echo "$READY_RESPONSE" | head -n -1)
          READY_CODE=$(echo "$READY_RESPONSE" | tail -n 1)

          echo "Status: $READY_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Body: $READY_BODY" | tee -a $GITHUB_STEP_SUMMARY
          echo "Readiness Response: $READY_BODY" >> "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/db_probe_before_after.log"

          # Determine gate verdict
          echo "" | tee -a $GITHUB_STEP_SUMMARY
          echo "### EG-R1-5 Verdict Analysis" | tee -a $GITHUB_STEP_SUMMARY

          GATE_PASS=true

          # Check happy paths returned 2xx
          if [[ "$READ_HAPPY_CODE" =~ ^2[0-9][0-9]$ ]]; then
            echo "✅ READ happy path: $READ_HAPPY_CODE (2xx)" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "❌ READ happy path: $READ_HAPPY_CODE (expected 2xx)" | tee -a $GITHUB_STEP_SUMMARY
            GATE_PASS=false
          fi

          if [[ "$WRITE_HAPPY_CODE" =~ ^2[0-9][0-9]$ ]]; then
            echo "✅ WRITE happy path: $WRITE_HAPPY_CODE (2xx)" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "❌ WRITE happy path: $WRITE_HAPPY_CODE (expected 2xx)" | tee -a $GITHUB_STEP_SUMMARY
            GATE_PASS=false
          fi

          # Check invalid paths returned 4xx
          if [[ "$READ_INVALID_CODE" =~ ^4[0-9][0-9]$ ]]; then
            echo "✅ READ invalid path: $READ_INVALID_CODE (4xx)" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ READ invalid path: $READ_INVALID_CODE (expected 4xx, got different response)" | tee -a $GITHUB_STEP_SUMMARY
          fi

          if [[ "$WRITE_INVALID_CODE" =~ ^4[0-9][0-9]$ ]]; then
            echo "✅ WRITE invalid path: $WRITE_INVALID_CODE (4xx)" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ WRITE invalid path: $WRITE_INVALID_CODE (expected 4xx)" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # DB interaction evidence
          if echo "$DB_PROOF" | grep -q "attribution_events"; then
            echo "✅ DB interaction: attribution_events table exists" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ DB interaction: attribution_events table not found" | tee -a $GITHUB_STEP_SUMMARY
          fi

          if [ "$GATE_PASS" = true ]; then
            echo "PASS" > "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/verdict.txt"
            echo "" | tee -a $GITHUB_STEP_SUMMARY
            echo "✅ **EG-R1-5 PASS:** Live contract enforcement verified with DB interaction" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "FAIL" > "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/verdict.txt"
            echo "" | tee -a $GITHUB_STEP_SUMMARY
            echo "❌ **EG-R1-5 FAIL:** Contract enforcement issues detected" | tee -a $GITHUB_STEP_SUMMARY
          fi

      # ====================================================================
      # EG-R1-2: Prism Mock Boot (Prerequisite Verification)
      # ====================================================================
      - name: "EG-R1-2: Prism mock boot verification (prerequisite)"
        run: |
          echo "=== EG-R1-2: Prism Mock Boot (Prerequisite) ===" | tee -a $GITHUB_STEP_SUMMARY
          mkdir -p "$ARTIFACTS_DIR/PRISM_MOCKS"

          # Note: Prism mocks use source specs, not bundled (per docker-compose.mock.yml)
          echo "Starting Prism mocks with docker-compose..." | tee -a $GITHUB_STEP_SUMMARY

          if docker compose -f docker-compose.mock.yml up -d 2>&1 | tee "$ARTIFACTS_DIR/PRISM_MOCKS/prism_compose_up.log"; then
            echo "✅ docker compose up succeeded" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ docker compose up had issues" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Wait for services to start
          sleep 15

          # Check health status
          docker compose -f docker-compose.mock.yml ps 2>&1 | tee "$ARTIFACTS_DIR/PRISM_MOCKS/prism_health_ps.log"
          docker compose -f docker-compose.mock.yml ps | tee -a $GITHUB_STEP_SUMMARY

          # Sample requests to mocks
          echo "Sample mock requests:" | tee -a $GITHUB_STEP_SUMMARY

          # Health mock (port 4014)
          MOCK_HEALTH=$(curl -s -w "\n%{http_code}" http://localhost:4014/api/health 2>/dev/null || echo "connection_failed 000")
          MOCK_HEALTH_CODE=$(echo "$MOCK_HEALTH" | tail -n 1)
          echo "Health mock (4014): $MOCK_HEALTH_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Health mock: $MOCK_HEALTH" >> "$ARTIFACTS_DIR/PRISM_MOCKS/curl_mock_samples.log"

          # Auth mock (port 4010)
          MOCK_AUTH=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -H "X-Correlation-ID: $(uuidgen)" \
            -d '{"email":"test@example.com","password":"test"}' \
            http://localhost:4010/api/auth/login 2>/dev/null || echo "connection_failed 000")
          MOCK_AUTH_CODE=$(echo "$MOCK_AUTH" | tail -n 1)
          echo "Auth mock (4010): $MOCK_AUTH_CODE" | tee -a $GITHUB_STEP_SUMMARY
          echo "Auth mock: $MOCK_AUTH" >> "$ARTIFACTS_DIR/PRISM_MOCKS/curl_mock_samples.log"

          # Determine verdict
          if [[ "$MOCK_HEALTH_CODE" =~ ^2[0-9][0-9]$ ]] || [[ "$MOCK_AUTH_CODE" =~ ^2[0-9][0-9]$ ]]; then
            echo "PASS" > "$ARTIFACTS_DIR/PRISM_MOCKS/verdict.txt"
            echo "✅ **EG-R1-2 PASS:** Prism mocks operational (prerequisite verified)" | tee -a $GITHUB_STEP_SUMMARY
          else
            echo "FAIL" > "$ARTIFACTS_DIR/PRISM_MOCKS/verdict.txt"
            echo "⚠️ **EG-R1-2 FAIL:** Prism mocks not responding" | tee -a $GITHUB_STEP_SUMMARY
          fi

          # Cleanup mocks
          docker compose -f docker-compose.mock.yml down 2>/dev/null || true

      # ====================================================================
      # Cleanup and Artifact Generation
      # ====================================================================
      - name: "Cleanup processes"
        if: always()
        run: |
          # Stop backend if running
          if [ -f /tmp/backend.pid ]; then
            kill $(cat /tmp/backend.pid) 2>/dev/null || true
          fi

          # Stop postgres
          docker stop skeldir-r1-postgres 2>/dev/null || true
          docker rm skeldir-r1-postgres 2>/dev/null || true

          # Remove network
          docker network rm skeldir-r1-isolated 2>/dev/null || true

      - name: "Generate artifact manifest"
        if: always()
        run: |
          echo "Generating artifact manifest..." | tee -a $GITHUB_STEP_SUMMARY

          cd "$ARTIFACTS_DIR"

          # Generate SHA256 hashes for all artifacts
          find . -type f -name "*.log" -o -name "*.txt" -o -name "*.json" -o -name "*.sql" | while read f; do
            sha256sum "$f"
          done > manifest_hashes.txt

          # Create manifest JSON
          cat > ARTIFACT_MANIFEST.json <<EOF
          {
            "provenance": {
              "candidate_sha": "${{ github.sha }}",
              "run_id": "${{ github.run_id }}",
              "run_attempt": "${{ github.run_attempt }}",
              "captured_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            },
            "exit_gates_status": {
              "EG-R1-0": "PASS",
              "EG-R1-1": "$(cat CONTRACTS/verdict.txt 2>/dev/null || echo 'UNKNOWN')",
              "EG-R1-2": "$(cat PRISM_MOCKS/verdict.txt 2>/dev/null || echo 'UNKNOWN')",
              "EG-R1-3": "$(cat DB_SCHEMA/verdict.txt 2>/dev/null || echo 'UNKNOWN')",
              "EG-R1-4": "$(cat LIVE_STACK/verdict.txt 2>/dev/null || echo 'UNKNOWN')",
              "EG-R1-5": "$(cat CONTRACT_ENFORCEMENT/verdict.txt 2>/dev/null || echo 'UNKNOWN')"
            },
            "artifacts_index": "manifest_hashes.txt"
          }
          EOF

          cat ARTIFACT_MANIFEST.json | tee -a $GITHUB_STEP_SUMMARY

      # ====================================================================
      # R1 Final Summary
      # ====================================================================
      - name: "R1 Final Summary"
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## R1 Contract/Runtime Viability - Final Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Candidate SHA:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Exit Gate Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          EG_R1_0="PASS"
          EG_R1_1=$(cat "$ARTIFACTS_DIR/CONTRACTS/verdict.txt" 2>/dev/null || echo "UNKNOWN")
          EG_R1_2=$(cat "$ARTIFACTS_DIR/PRISM_MOCKS/verdict.txt" 2>/dev/null || echo "UNKNOWN")
          EG_R1_3=$(cat "$ARTIFACTS_DIR/DB_SCHEMA/verdict.txt" 2>/dev/null || echo "UNKNOWN")
          EG_R1_4=$(cat "$ARTIFACTS_DIR/LIVE_STACK/verdict.txt" 2>/dev/null || echo "UNKNOWN")
          EG_R1_5=$(cat "$ARTIFACTS_DIR/CONTRACT_ENFORCEMENT/verdict.txt" 2>/dev/null || echo "UNKNOWN")

          echo "| Gate | Status | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| EG-R1-0 | $( [ \"$EG_R1_0\" = \"PASS\" ] && echo '✅ PASS' || echo '❌ FAIL' ) | Evidence Anchor & Provenance |" >> $GITHUB_STEP_SUMMARY
          echo "| EG-R1-1 | $( [ \"$EG_R1_1\" = \"PASS\" ] && echo '✅ PASS' || echo '❌ FAIL' ) | OpenAPI Validation + Smoke Codegen |" >> $GITHUB_STEP_SUMMARY
          echo "| EG-R1-2 | $( [ \"$EG_R1_2\" = \"PASS\" ] && echo '✅ PASS' || echo '⚠️ PREREQ' ) | Prism Mock Boot (Prerequisite) |" >> $GITHUB_STEP_SUMMARY
          echo "| EG-R1-3 | $( [ \"$EG_R1_3\" = \"PASS\" ] && echo '✅ PASS' || echo '❌ FAIL' ) | Fresh DB Schema Apply + Idempotency |" >> $GITHUB_STEP_SUMMARY
          echo "| EG-R1-4 | $( [ \"$EG_R1_4\" = \"PASS\" ] && echo '✅ PASS' || echo '❌ FAIL' ) | Live Stack Boot + /health /metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| **EG-R1-5** | $( [ \"$EG_R1_5\" = \"PASS\" ] && echo '✅ PASS' || echo '❌ FAIL' ) | **Live Contract Enforcement (CLOSURE)** |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine overall R1 status
          if [ "$EG_R1_1" = "PASS" ] && [ "$EG_R1_3" = "PASS" ] && [ "$EG_R1_4" = "PASS" ] && [ "$EG_R1_5" = "PASS" ]; then
            echo "### ✅ R1 COMPLETE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All critical exit gates PASS. System is invokable end-to-end at runtime." >> $GITHUB_STEP_SUMMARY
            echo "**R2 Authorization:** ✅ AUTHORIZED" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ❌ R1 INCOMPLETE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "One or more critical exit gates failed. Remediation required." >> $GITHUB_STEP_SUMMARY
            echo "**R2 Authorization:** ❌ BLOCKED" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifact Package:** r1-artifacts-${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

      - name: "Upload R1 artifacts"
        if: always()
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3  # v4.3.1 pinned by SHA
        with:
          name: r1-artifacts-${{ github.sha }}
          path: ${{ env.ARTIFACTS_DIR }}
          retention-days: 90
