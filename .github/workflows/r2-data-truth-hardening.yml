# R2 Data-Truth Hardening Validation
#
# Mission (non-negotiable):
# 1) DB prevents violations (RLS + triggers + privileges)
# 2) Application/worker fabric is innocent:
#    - AUTHORITATIVE: Postgres log statement capture over a provably executed window
#    - MANDATORY secondary: ORM window capture cross-check
#    - CO-PRIMARY for latent paths: static behavioral innocence + canary integrity
#
# This workflow is structured to avoid "false greens":
# - Each exit gate step is allowed to run to completion (continue-on-error),
#   and a final aggregator step fails the job if any gate failed.

name: "R2: Data-Truth Hardening"

on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - 'db/schema/**'
      - 'backend/app/**'
      - 'scripts/r2/**'
      - '.github/workflows/r2-data-truth-hardening.yml'

env:
  POSTGRES_USER: skeldir_r2_test
  POSTGRES_PASSWORD: skeldir_r2_test_password
  POSTGRES_DB: skeldir_r2_test
  POSTGRES_DIGEST: postgres@sha256:b3968e348b48f1198cc6de6611d055dbad91cd561b7990c406c3fc28d7095b21
  R2_NUM_SCENARIOS: "6"

jobs:
  r2-validation:
    name: "R2 Data-Truth Hardening"
    runs-on: ubuntu-22.04
    env:
      ARTIFACTS_DIR: ${{ github.workspace }}/artifacts/runtime_r2/${{ github.sha }}

    steps:
      - name: "Checkout repository (immutable ref)"
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1 pinned by SHA
        with:
          fetch-depth: 0

      - name: "Setup Python (for runtime suite + audits)"
        uses: actions/setup-python@82c7e631bb3cdc910f68e0081d67478d79c6982d  # v5.1.0 pinned by SHA
        with:
          python-version: "3.11"

      - name: "Install container runtime"
        run: |
          set -euo pipefail
          bash scripts/ci/install_container_runtime.sh

      - name: "Install backend dependencies"
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt -r backend/requirements-dev.txt

      # ====================================================================
      # EG-R2-0: Evidence Anchoring & Closed-Set Declaration
      # ====================================================================
      - name: "EG-R2-0: Evidence anchoring & closed-set declaration"
        id: eg_r2_0
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR"

          CANDIDATE_SHA="$(git rev-parse HEAD)"
          echo "R2_CANDIDATE_SHA=${{ github.sha }}" >> "$GITHUB_ENV"

          echo "=== EG-R2-0: Evidence Anchoring & Closed-Set Declaration ===" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "CANDIDATE_SHA=$CANDIDATE_SHA" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "RUN_ID=${{ github.run_id }}" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "RUN_URL=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "" | tee -a "$GITHUB_STEP_SUMMARY"

          cat > "$ARTIFACTS_DIR/R2_ENV_SNAPSHOT.json" <<EOF
          {
            "candidate_sha": "${{ github.sha }}",
            "run_id": "${{ github.run_id }}",
            "run_attempt": "${{ github.run_attempt }}",
            "captured_at_utc": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "substrate": "ubuntu-22.04",
            "container_runtime_version": "$(podman --version | awk '{print $3}' | tr -d ',')",
            "python_version": "$(python3 --version | awk '{print $2}')"
          }
          EOF

          # Closed set: tenant-scoped tables (ENABLE RLS)
          python - <<'PY' > "$ARTIFACTS_DIR/CLOSED_SET_TENANT_TABLES.txt"
          import re
          from pathlib import Path
          text = Path("db/schema/canonical_schema.sql").read_text(encoding="utf-8", errors="replace").splitlines()
          pat = re.compile(r"^\s*ALTER\s+TABLE(?:\s+ONLY)?\s+public\.([a-zA-Z0-9_]+)\s+ENABLE\s+ROW\s+LEVEL\s+SECURITY\s*;\s*$")
          tables = sorted({m.group(1) for line in text if (m := pat.search(line))})
          for t in tables:
            print(t)
          PY

          # Closed set: immutable tables (prevent_mutation triggers)
          IMMUTABLE_TABLES=$(grep -E "trg_.*_prevent_mutation" db/schema/canonical_schema.sql \
            | grep "CREATE TRIGGER" \
            | sed 's/.*ON public\\.//' | sed 's/ FOR.*//' | sort -u)
          echo "$IMMUTABLE_TABLES" > "$ARTIFACTS_DIR/CLOSED_SET_IMMUTABLE_TABLES.txt"

          # Closed set: PII-guarded tables (pii guardrail triggers)
          PII_TABLES=$(grep -E "trg_pii_guardrail" db/schema/canonical_schema.sql \
            | grep "CREATE TRIGGER" \
            | sed 's/.*ON public\\.//' | sed 's/ FOR.*//' | sort -u)
          echo "$PII_TABLES" > "$ARTIFACTS_DIR/CLOSED_SET_PII_TABLES.txt"

          # Schema fingerprint
          SCHEMA_HASH=$(sha256sum db/schema/canonical_schema.sql | awk '{print $1}')
          echo "$SCHEMA_HASH" > "$ARTIFACTS_DIR/SCHEMA_FINGERPRINT.txt"

          echo "EG-R2-0_PASS" | tee -a "$GITHUB_STEP_SUMMARY"

      # ====================================================================
      # Setup: podman network and Postgres
      # ====================================================================
      - name: "Create podman network for R2"
        run: |
          set -euo pipefail
          podman network create skeldir-r2-isolated || true

      - name: "Start Postgres container (digest-pinned, with statement logging)"
        run: |
          set -euo pipefail

          podman run -d \
            --name skeldir-r2-postgres \
            --network skeldir-r2-isolated \
            -p 5432:5432 \
            -e POSTGRES_USER=$POSTGRES_USER \
            -e POSTGRES_PASSWORD=$POSTGRES_PASSWORD \
            -e POSTGRES_DB=$POSTGRES_DB \
            $POSTGRES_DIGEST \
            -c log_statement=all \
            -c log_destination=stderr \
            -c logging_collector=off

          echo "Waiting for Postgres to be ready..."
          for i in {1..60}; do
            if podman exec skeldir-r2-postgres pg_isready -U $POSTGRES_USER >/dev/null 2>&1; then
              if podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -c "SELECT 1" >/dev/null 2>&1; then
                break
              fi
            fi
            sleep 1
          done
          sleep 2

          # Capture dynamically allocated host port for runtime scenarios.
          R2_PG_PORT=$(podman port skeldir-r2-postgres 5432/tcp | head -1 | awk -F: '{print $2}')
          echo "R2_PG_PORT=$R2_PG_PORT" >> "$GITHUB_ENV"
          echo "Postgres host port: $R2_PG_PORT" | tee -a "$GITHUB_STEP_SUMMARY"

      - name: "Provision canonical runtime role prerequisites"
        run: |
          set -euo pipefail
          podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -v ON_ERROR_STOP=1 -c "
            DO \$\$
            BEGIN
              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_rw') THEN
                CREATE ROLE app_rw NOLOGIN;
              END IF;

              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_ro') THEN
                CREATE ROLE app_ro NOLOGIN;
              END IF;

              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'app_user') THEN
                CREATE ROLE app_user LOGIN PASSWORD 'app_user' NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT;
              ELSE
                ALTER ROLE app_user LOGIN PASSWORD 'app_user' NOSUPERUSER NOCREATEDB NOCREATEROLE INHERIT;
              END IF;

              GRANT app_rw TO app_user;
              GRANT app_ro TO app_user;
            END
            \$\$;
          "

      - name: "Apply canonical schema"
        run: |
          set -euo pipefail
          # Reorder webhook resolver creation so tenants exists before SQL body validation.
          python - <<'PY'
          import re
          from pathlib import Path

          source = Path("db/schema/canonical_schema.sql")
          target = Path("/tmp/canonical_schema_r2_bootstrap.sql")
          text = source.read_text(encoding="utf-8")
          pattern = re.compile(
              r"\nCREATE FUNCTION security\.resolve_tenant_webhook_secrets\(api_key_hash text\).*?\n\s*\$_\$;\n",
              re.DOTALL,
          )
          match = pattern.search(text)
          if not match:
              raise SystemExit("unable to locate resolve_tenant_webhook_secrets function block in canonical schema")
          function_block = match.group(0)
          reordered = text[:match.start()] + "\n" + text[match.end():] + function_block
          target.write_text(reordered, encoding="utf-8")
          PY
          podman exec -i skeldir-r2-postgres psql -v ON_ERROR_STOP=1 -U $POSTGRES_USER -d $POSTGRES_DB < /tmp/canonical_schema_r2_bootstrap.sql

      - name: "Create application role (non-superuser) for RLS tests"
        run: |
          set -euo pipefail
          podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -v ON_ERROR_STOP=1 -c "
            DO \$\$
            BEGIN
              IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'r2_app_role') THEN
                CREATE ROLE r2_app_role WITH LOGIN PASSWORD 'r2_app_password' NOSUPERUSER NOINHERIT;
              END IF;
            END
            \$\$;

            GRANT CONNECT ON DATABASE $POSTGRES_DB TO r2_app_role;
            GRANT USAGE ON SCHEMA public TO r2_app_role;
            GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO r2_app_role;
            GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO r2_app_role;

            -- Defense-in-depth: immutable tables are read-only at privilege layer too.
            REVOKE UPDATE, DELETE ON TABLE attribution_events FROM r2_app_role;
            REVOKE UPDATE, DELETE ON TABLE revenue_ledger FROM r2_app_role;
          "

      - name: "Seed R2 scenario prerequisites (tenants + channel taxonomy)"
        run: |
          set -euo pipefail

          podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -v ON_ERROR_STOP=1 -c "
            INSERT INTO tenants (id, name, api_key_hash, notification_email, created_at, updated_at)
            VALUES
              ('11111111-1111-1111-1111-111111111111', 'R2 Scenario Tenant A', 'hash_a', 'a@test.invalid', NOW(), NOW()),
              ('22222222-2222-2222-2222-222222222222', 'R2 Scenario Tenant B', 'hash_b', 'b@test.invalid', NOW(), NOW())
            ON CONFLICT (id) DO NOTHING;
          " >/dev/null

          podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -v ON_ERROR_STOP=1 -c "
            INSERT INTO channel_taxonomy (code, family, is_paid, display_name, is_active, state, created_at)
            VALUES
              ('unknown', 'unknown', false, 'Unknown', true, 'active', NOW()),
              ('direct', 'direct', false, 'Direct', true, 'active', NOW()),
              ('email', 'email', false, 'Email', true, 'active', NOW()),
              ('facebook_brand', 'paid_social', true, 'Facebook Brand', true, 'active', NOW()),
              ('facebook_paid', 'paid_social', true, 'Facebook Paid', true, 'active', NOW()),
              ('google_display_paid', 'paid_search', true, 'Google Display Paid', true, 'active', NOW()),
              ('google_search_paid', 'paid_search', true, 'Google Search Paid', true, 'active', NOW()),
              ('organic', 'organic', false, 'Organic', true, 'active', NOW()),
              ('referral', 'referral', false, 'Referral', true, 'active', NOW()),
              ('tiktok_paid', 'paid_social', true, 'TikTok Paid', true, 'active', NOW())
            ON CONFLICT (code) DO NOTHING;
          " >/dev/null

      - name: "Initialize window identifiers"
        run: |
          set -euo pipefail
          echo "R2_WINDOW_ID=$(date -u +%Y%m%d%H%M%S)-${{ github.run_id }}-${{ github.run_attempt }}" >> "$GITHUB_ENV"
          echo "R2_CANARY_WINDOW_ID=canary-$(date -u +%Y%m%d%H%M%S)-${{ github.run_id }}-${{ github.run_attempt }}" >> "$GITHUB_ENV"

      # ====================================================================
      # EG-R2-FIX-2 - DB Capture Enablement Proof
      # ====================================================================
      - name: "EG-R2-FIX-2: DB capture enablement proof"
        id: eg_r2_fix_2
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/DB_CAPTURE_PROOF"

          LOG_STATEMENT=$(podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SHOW log_statement;" | tr -d ' ')
          LOG_DESTINATION=$(podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SHOW log_destination;" | tr -d ' ')
          LOGGING_COLLECTOR=$(podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -t -c "SHOW logging_collector;" | tr -d ' ')

          echo "EG_R2_FIX_2_DB_CAPTURE_ENABLEMENT_PROOF" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "SHOW_log_statement=$LOG_STATEMENT" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "SHOW_log_destination=$LOG_DESTINATION" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "SHOW_logging_collector=$LOGGING_COLLECTOR" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "END_PROOF" | tee -a "$GITHUB_STEP_SUMMARY"

          {
            echo "log_statement=$LOG_STATEMENT"
            echo "log_destination=$LOG_DESTINATION"
            echo "logging_collector=$LOGGING_COLLECTOR"
          } > "$ARTIFACTS_DIR/DB_CAPTURE_PROOF/db_logging_config.txt"

          if [ "$LOG_STATEMENT" != "all" ]; then
            echo "FAIL: expected log_statement=all" | tee -a "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          if [ "$LOGGING_COLLECTOR" != "off" ]; then
            echo "FAIL: expected logging_collector=off (must log to stderr for podman logs capture)" | tee -a "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      # ====================================================================
      # DB prevents violations (RLS + triggers + privileges)
      # ====================================================================
      - name: "EG-R2-ENFORCEMENT: DB prevents violations"
        id: eg_r2_enforcement
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/DB_ENFORCEMENT"

          FAILURES=()

          echo "R2_DB_ENFORCEMENT_VERDICT"

          # (1) RLS enabled + forced on tenant-scoped tables (closed set derived from schema)
          echo "RLS_STATUS_BEGIN"
          while IFS= read -r table; do
            [ -z "$table" ] && continue
            row=$(podman exec skeldir-r2-postgres psql -U $POSTGRES_USER -d $POSTGRES_DB -t -A -c "SELECT relrowsecurity, relforcerowsecurity FROM pg_class WHERE oid=('public.${table}'::regclass);" | tr -d ' ')
            echo "${table}=${row}"
            if [ "$table" = "worker_failed_jobs" ]; then
              # Accept either forced-RLS or plain RLS for this operational table.
              if ! echo "$row" | grep -qE "t\\|(t|f)"; then
                FAILURES+=("RLS_NOT_ENFORCED:${table}=${row}")
              fi
            elif ! echo "$row" | grep -q "t|t"; then
              FAILURES+=("RLS_NOT_ENFORCED:${table}=${row}")
            fi
          done < "$ARTIFACTS_DIR/CLOSED_SET_TENANT_TABLES.txt"
          echo "RLS_STATUS_END"

          # (2) Cross-tenant denial (SELECT Tenant B rows while scoped to Tenant A must be 0)
          cat > /tmp/r2_cross_tenant.sql <<'EOSQL'
          SET app.current_tenant_id = '11111111-1111-1111-1111-111111111111';
          INSERT INTO attribution_events (
            event_id, tenant_id, event_timestamp, event_type, source_url, attribution_model, created_at, channel
          ) VALUES (
            'r2_enforce_a_' || gen_random_uuid()::text,
            '11111111-1111-1111-1111-111111111111',
            NOW(),
            'page_view',
            'https://r2.invalid/enforce',
            'last_touch',
            NOW(),
            'organic'
          ) ON CONFLICT DO NOTHING;
          SELECT COUNT(*) FROM attribution_events WHERE tenant_id = '22222222-2222-2222-2222-222222222222';
          EOSQL
          podman cp /tmp/r2_cross_tenant.sql skeldir-r2-postgres:/tmp/r2_cross_tenant.sql
          cross_count=$(podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -q -t -A -f /tmp/r2_cross_tenant.sql 2>&1 | tail -n 1 | tr -d ' ')
          echo "CROSS_TENANT_B_ROWS_VISIBLE_TO_A=${cross_count}"
          if ! echo "$cross_count" | grep -qE '^[0]+$'; then
            FAILURES+=("CROSS_TENANT_DENIAL_FAILED:count=${cross_count}")
          fi

          # (3) PII guardrail (attempt insert with prohibited key must fail)
          cat > /tmp/r2_pii_fail.sql <<'EOSQL'
          SET app.current_tenant_id = '11111111-1111-1111-1111-111111111111';
          INSERT INTO attribution_events (
            event_id, tenant_id, event_timestamp, event_type, source_url, attribution_model, created_at, channel, raw_payload
          ) VALUES (
            'r2_pii_' || gen_random_uuid()::text,
            '11111111-1111-1111-1111-111111111111',
            NOW(),
            'page_view',
            'https://r2.invalid/pii',
            'last_touch',
            NOW(),
            'organic',
            '{"email":"x@test.invalid"}'::jsonb
          );
          EOSQL
          podman cp /tmp/r2_pii_fail.sql skeldir-r2-postgres:/tmp/r2_pii_fail.sql
          pii_result=$(podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -f /tmp/r2_pii_fail.sql 2>&1 || true)
          pii_error_snippet=$(echo "$pii_result" | grep -i -m1 -E 'PII key detected|guardrail|ERROR' || true)
          echo "PII_INSERT_ATTEMPT_ERROR_SNIPPET=${pii_error_snippet}"
          if ! echo "$pii_result" | grep -qiE "pii|guardrail|not allowed|violat"; then
            FAILURES+=("PII_GUARDRAIL_NOT_ENFORCED")
          fi

          # (4) Immutability enforcement (UPDATE/DELETE blocked on immutable tables)
          cat > /tmp/r2_immut_update.sql <<'EOSQL'
          SET app.current_tenant_id = '11111111-1111-1111-1111-111111111111';
          UPDATE attribution_events SET event_type = 'r2_immut' WHERE 1=0;
          EOSQL
          podman cp /tmp/r2_immut_update.sql skeldir-r2-postgres:/tmp/r2_immut_update.sql
          immut_update=$(podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -f /tmp/r2_immut_update.sql 2>&1 || true)
          if ! echo "$immut_update" | grep -qiE "immutable|permission denied|not allowed"; then
            FAILURES+=("ATTRIBUTION_EVENTS_UPDATE_NOT_BLOCKED")
          fi

          cat > /tmp/r2_immut_delete.sql <<'EOSQL'
          SET app.current_tenant_id = '11111111-1111-1111-1111-111111111111';
          DELETE FROM revenue_ledger WHERE 1=0;
          EOSQL
          podman cp /tmp/r2_immut_delete.sql skeldir-r2-postgres:/tmp/r2_immut_delete.sql
          immut_delete=$(podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -f /tmp/r2_immut_delete.sql 2>&1 || true)
          if ! echo "$immut_delete" | grep -qiE "immutable|permission denied|not allowed"; then
            FAILURES+=("REVENUE_LEDGER_DELETE_NOT_BLOCKED")
          fi

          echo "FAILURE_COUNT=${#FAILURES[@]}"
          if [ "${#FAILURES[@]}" -gt 0 ]; then
            echo "FAILURES=$(IFS=';'; echo "${FAILURES[*]}")"
            echo "END_VERDICT"
            exit 1
          fi
          echo "END_VERDICT"

      # ====================================================================
      # EG-R2-FIX-7 - Static Behavioral Innocence (latent paths)
      # ====================================================================
      - name: "EG-R2-FIX-7: Static behavioral innocence"
        id: eg_r2_fix_7
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/STATIC_AUDIT"
          python scripts/r2/static_behavioral_audit.py \
            --repo-root . \
            --artifact-json "$ARTIFACTS_DIR/STATIC_AUDIT/verdict.json" \
            | tee "$ARTIFACTS_DIR/STATIC_AUDIT/verdict.log"

      # ====================================================================
      # EG-R2-FIX-8 - Canary Integrity (anti-theater)
      # ====================================================================
      - name: "EG-R2-FIX-8: Canary integrity (DB parser + static detector)"
        id: eg_r2_fix_8
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/CANARY"

          # DB canary window emission: deliberate destructive statement (WHERE 1=0) that must be visible in Postgres logs.
          podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -c \
            "SELECT 'R2_WINDOW_START::${R2_CANDIDATE_SHA}::${R2_CANARY_WINDOW_ID}';" >/dev/null 2>&1 || true
          podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -c \
            "SELECT set_config('app.current_tenant_id', '11111111-1111-1111-1111-111111111111', false);" >/dev/null 2>&1 || true
          podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -c \
            "UPDATE attribution_events SET event_type = 'r2_canary' WHERE 1=0;" >/dev/null 2>&1 || true
          podman exec -e PGPASSWORD=r2_app_password skeldir-r2-postgres psql -U r2_app_role -d $POSTGRES_DB -c \
            "SELECT 'R2_WINDOW_END::${R2_CANDIDATE_SHA}::${R2_CANARY_WINDOW_ID}';" >/dev/null 2>&1 || true

          podman logs skeldir-r2-postgres > "$ARTIFACTS_DIR/CANARY/postgres_full_log.txt" 2>&1

          set +e
          python scripts/r2/db_log_window_audit.py \
            --log-file "$ARTIFACTS_DIR/CANARY/postgres_full_log.txt" \
            --candidate-sha "$R2_CANDIDATE_SHA" \
            --window-id "$R2_CANARY_WINDOW_ID" \
            --num-scenarios 0 \
            --artifact-json "$ARTIFACTS_DIR/CANARY/db_canary_verdict.json"
          canary_exit=$?
          set -e
          if [ "$canary_exit" -eq 0 ]; then
            echo "FAIL: DB parser did not fail on canary window" | tee -a "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          python - <<'PY'
          import json
          import os
          from pathlib import Path
          artifacts_dir = Path(os.environ["ARTIFACTS_DIR"])
          path = artifacts_dir / "CANARY" / "db_canary_verdict.json"
          verdict = json.loads(path.read_text(encoding="utf-8"))
          match_count = int(verdict.get("match_count_destructive_on_immutable", 0))
          if match_count <= 0:
            raise SystemExit(f"FAIL: canary window did not produce destructive matches (match_count={match_count})")
          print(f"R2_DB_CANARY_MATCH_COUNT={match_count}")
          PY

          # Static canary injection: detector must fail when canary exists, then pass after removal.
          CANARY_FILE="backend/app/_r2_static_canary_violation.py"
          cat > "$CANARY_FILE" << 'EOCANARY'
          from sqlalchemy import text
          VIOLATION_1 = text("DELETE FROM attribution_events WHERE 1=0")
          VIOLATION_2 = text("UPDATE attribution_events SET event_type = 'canary' WHERE 1=0")
          VIOLATION_3 = "TRUNCATE TABLE revenue_ledger"
          EOCANARY

          set +e
          python scripts/r2/static_behavioral_audit.py --repo-root . --artifact-json "$ARTIFACTS_DIR/CANARY/static_fail_verdict.json" > "$ARTIFACTS_DIR/CANARY/static_fail.log" 2>&1
          static_fail_exit=$?
          set -e
          if [ "$static_fail_exit" -eq 0 ]; then
            echo "FAIL: static audit did not fail with canary present" | tee -a "$GITHUB_STEP_SUMMARY"
            rm -f "$CANARY_FILE"
            exit 1
          fi
          rm -f "$CANARY_FILE"
          python scripts/r2/static_behavioral_audit.py --repo-root . --artifact-json "$ARTIFACTS_DIR/CANARY/static_pass_verdict.json" > "$ARTIFACTS_DIR/CANARY/static_pass.log" 2>&1

      # ====================================================================
      # EG-R2-FIX-1 - Scenario Suite Hard Gate
      # ====================================================================
      - name: "EG-R2-FIX-1: Runtime scenario suite (hard gate)"
        id: eg_r2_fix_1
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/SCENARIO_SUITE"

          export PYTHONPATH="${{ github.workspace }}/backend"
          export DATABASE_URL="postgresql+asyncpg://r2_app_role:r2_app_password@localhost:${R2_PG_PORT}/${POSTGRES_DB}"
          export CI="true"
          export TESTING="1"

          python scripts/r2/runtime_scenario_suite.py \
            --candidate-sha "$R2_CANDIDATE_SHA" \
            --window-id "$R2_WINDOW_ID" \
            --orm-verdict-json "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_verdict.json" \
            | tee "$ARTIFACTS_DIR/SCENARIO_SUITE/scenario_suite.log"

      # ====================================================================
      # EG-R2-FIX-3 - DB Window Binding + Per-Scenario Activity
      # ====================================================================
      - name: "EG-R2-FIX-3: DB window binding + per-scenario DB activity"
        id: eg_r2_fix_3
        continue-on-error: true
        run: |
          set -euo pipefail
          mkdir -p "$ARTIFACTS_DIR/DB_CAPTURE"

          podman logs skeldir-r2-postgres > "$ARTIFACTS_DIR/DB_CAPTURE/postgres_full_log.txt" 2>&1

          echo "R2_DB_LOG_HEAD_200_LINES" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "\`\`\`" | tee -a "$GITHUB_STEP_SUMMARY"
          sed -n '1,200p' "$ARTIFACTS_DIR/DB_CAPTURE/postgres_full_log.txt" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "\`\`\`" | tee -a "$GITHUB_STEP_SUMMARY"

          python scripts/r2/db_log_window_audit.py \
            --log-file "$ARTIFACTS_DIR/DB_CAPTURE/postgres_full_log.txt" \
            --candidate-sha "$R2_CANDIDATE_SHA" \
            --window-id "$R2_WINDOW_ID" \
            --num-scenarios "$R2_NUM_SCENARIOS" \
            --no-enforce-forbidden \
            --artifact-json "$ARTIFACTS_DIR/DB_CAPTURE/window_verdict.json" \
            | tee "$ARTIFACTS_DIR/DB_CAPTURE/window_verdict.log"

      # ====================================================================
      # EG-R2-FIX-4 - DB Runtime Innocence (AUTHORITATIVE)
      # ====================================================================
      - name: "EG-R2-FIX-4: DB runtime innocence (authoritative)"
        id: eg_r2_fix_4
        continue-on-error: true
        run: |
          set -euo pipefail
          python - <<'PY'
          import json
          import os
          from pathlib import Path
          artifacts_dir = Path(os.environ["ARTIFACTS_DIR"])
          path = artifacts_dir / "DB_CAPTURE" / "window_verdict.json"
          if not path.exists():
            raise SystemExit("FAIL: missing DB window verdict json (did EG-R2-FIX-3 run?)")
          verdict = json.loads(path.read_text(encoding="utf-8"))
          match_count = int(verdict.get("match_count_destructive_on_immutable", 0))
          print("R2_DB_RUNTIME_INNOCENCE_VERDICT")
          print("IMMUTABLE_TABLE_SET=attribution_events,revenue_ledger")
          print("DESTRUCTIVE_VERBS=ALTER,DELETE,TRUNCATE,UPDATE")
          print(f"DB_FORBIDDEN_MATCH_COUNT={match_count}")
          if match_count != 0:
            print("FAILURES=DB_FORBIDDEN_MATCH_COUNT_NONZERO")
          print("END_VERDICT")
          raise SystemExit(1 if match_count != 0 else 0)
          PY

      # ====================================================================
      # EG-R2-FIX-5 - ORM Runtime Innocence (MANDATORY secondary)
      # ====================================================================
      - name: "EG-R2-FIX-5: ORM runtime innocence (mandatory cross-check)"
        id: eg_r2_fix_5
        continue-on-error: true
        run: |
          set -euo pipefail
          if [ ! -f "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_verdict.json" ]; then
            echo "FAIL: missing orm_verdict.json (did EG-R2-FIX-1 run?)"
            exit 1
          fi
          python scripts/r2/orm_window_audit.py \
            --orm-window-json "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_verdict.json" \
            --num-scenarios "$R2_NUM_SCENARIOS" \
            | tee "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_gate.log"

      # ====================================================================
      # EG-R2-FIX-6 - Instrument Consistency (DB vs ORM)
      # ====================================================================
      - name: "EG-R2-FIX-6: Instrument consistency (DB vs ORM)"
        id: eg_r2_fix_6
        continue-on-error: true
        run: |
          set -euo pipefail
          if [ ! -f "$ARTIFACTS_DIR/DB_CAPTURE/window_verdict.json" ]; then
            echo "FAIL: missing DB window verdict json"
            exit 1
          fi
          if [ ! -f "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_verdict.json" ]; then
            echo "FAIL: missing ORM window verdict json"
            exit 1
          fi
          python scripts/r2/instrument_consistency_gate.py \
            --db-window-json "$ARTIFACTS_DIR/DB_CAPTURE/window_verdict.json" \
            --orm-window-json "$ARTIFACTS_DIR/SCENARIO_SUITE/orm_verdict.json" \
            --num-scenarios "$R2_NUM_SCENARIOS" \
            | tee "$ARTIFACTS_DIR/DB_CAPTURE/instrument_consistency.log"

      # ====================================================================
      # EG-R2-FIX-9 - Truth Record (browser-visible)
      # ====================================================================
      - name: "EG-R2-FIX-9: Truth record (browser-visible)"
        id: eg_r2_fix_9
        continue-on-error: true
        run: |
          set -euo pipefail
          cat > "$ARTIFACTS_DIR/R2_TRUTH_RECORD.md" <<EOF
          # R2 Data-Truth Hardening Truth Record

          - Candidate SHA: ${{ github.sha }}
          - Run URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ## Exit Gates (Expected PASS for R2 COMPLETE)

          - EG-R2-FIX-1 Scenario hard gate: ${{ steps.eg_r2_fix_1.outcome }}
          - EG-R2-FIX-2 DB capture enablement: ${{ steps.eg_r2_fix_2.outcome }}
          - EG-R2-FIX-3 DB window binding/activity: ${{ steps.eg_r2_fix_3.outcome }}
          - EG-R2-FIX-4 DB runtime innocence (authoritative): ${{ steps.eg_r2_fix_4.outcome }}
          - EG-R2-FIX-5 ORM runtime innocence (mandatory): ${{ steps.eg_r2_fix_5.outcome }}
          - EG-R2-FIX-6 Instrument consistency: ${{ steps.eg_r2_fix_6.outcome }}
          - EG-R2-FIX-7 Static behavioral innocence: ${{ steps.eg_r2_fix_7.outcome }}
          - EG-R2-FIX-8 Canary integrity: ${{ steps.eg_r2_fix_8.outcome }}
          - EG-R2-FIX-9 Documentary coherence: pending repo update (this record is run-generated)

          ## DB enforcement (mission requirement)
          - EG-R2-ENFORCEMENT DB prevents violations: ${{ steps.eg_r2_enforcement.outcome }}
          EOF

          echo "R2_TRUTH_RECORD_BEGIN" | tee -a "$GITHUB_STEP_SUMMARY"
          cat "$ARTIFACTS_DIR/R2_TRUTH_RECORD.md" | tee -a "$GITHUB_STEP_SUMMARY"
          echo "R2_TRUTH_RECORD_END" | tee -a "$GITHUB_STEP_SUMMARY"

      # ====================================================================
      # Aggregate and fail the job if any exit gate failed.
      # ====================================================================
      - name: "R2 Gate Aggregation (hard fail on any gate)"
        if: always()
        run: |
          set -euo pipefail
          failures=()

          check () {
            local name="$1"
            local outcome="$2"
            if [ "$outcome" != "success" ]; then
              failures+=("${name}=${outcome}")
            fi
          }

          check "EG-R2-0" "${{ steps.eg_r2_0.outcome }}"
          check "EG-R2-ENFORCEMENT" "${{ steps.eg_r2_enforcement.outcome }}"
          check "EG-R2-FIX-1" "${{ steps.eg_r2_fix_1.outcome }}"
          check "EG-R2-FIX-2" "${{ steps.eg_r2_fix_2.outcome }}"
          check "EG-R2-FIX-3" "${{ steps.eg_r2_fix_3.outcome }}"
          check "EG-R2-FIX-4" "${{ steps.eg_r2_fix_4.outcome }}"
          check "EG-R2-FIX-5" "${{ steps.eg_r2_fix_5.outcome }}"
          check "EG-R2-FIX-6" "${{ steps.eg_r2_fix_6.outcome }}"
          check "EG-R2-FIX-7" "${{ steps.eg_r2_fix_7.outcome }}"
          check "EG-R2-FIX-8" "${{ steps.eg_r2_fix_8.outcome }}"

          if [ "${#failures[@]}" -gt 0 ]; then
            echo "R2_GATE_AGGREGATION_VERDICT"
            echo "FAILURE_COUNT=${#failures[@]}"
            echo "FAILURES=$(IFS=';'; echo "${failures[*]}")"
            echo "END_VERDICT"
            exit 1
          fi

          echo "R2_GATE_AGGREGATION_VERDICT"
          echo "FAILURE_COUNT=0"
          echo "END_VERDICT"

      - name: "Cleanup podman resources"
        if: always()
        run: |
          podman stop skeldir-r2-postgres || true
          podman rm skeldir-r2-postgres || true
          podman network rm skeldir-r2-isolated || true

      - name: "Upload R2 validation artifacts"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: r2-validation-artifacts-${{ github.sha }}
          path: ${{ github.workspace }}/artifacts/runtime_r2/
          retention-days: 90
