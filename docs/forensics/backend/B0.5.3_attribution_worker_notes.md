# B0.5.3 Attribution Worker Notes

**Version**: 1.0.0  
**Last Updated**: 2025-12-15  
**Phase**: B0.5.3.3 Revenue Input Semantics Resolution

---

## Overview

This document defines the contract and behavior of the B0.5.3 attribution worker (`app.tasks.attribution.recompute_window`), including revenue input semantics, idempotency guarantees, and read/write matrix.

---

## B0.5.3.3 Revenue Input Contract

**Contract Choice**: **Contract B** (Worker ignores `revenue_ledger` in B0.5.3)

### Contract Definition

The attribution worker **does not read from `revenue_ledger`** in B0.5.3. All allocations are computed deterministically from `attribution_events` only.

**Rationale**:
1. **Schema circularity**: `revenue_ledger.allocation_id` is NOT NULL FK to `attribution_allocations`, creating a circular dependency (ledger requires allocations, allocations created by worker)
2. **Current emptiness**: `revenue_ledger` is effectively unpopulated in B0.5.3 (no upstream population path exists)
3. **Roadmap alignment**: Verified revenue ingestion + matching is planned for B2.2/B2.3 (webhook capture + order_id matching)
4. **Zero code changes**: Worker already implements this contract (reads events, writes allocations, ignores ledger)

### Read/Write Matrix

| Table | Read | Write | Notes |
|-------|------|-------|-------|
| `attribution_events` | ✅ YES | ❌ NO | Primary input: read-only, append-only table |
| `attribution_allocations` | ❌ NO | ✅ YES | Primary output: UPSERT via unique constraint |
| `revenue_ledger` | ❌ NO | ❌ NO | **Ignored in B0.5.3** (downstream, not input) |
| `attribution_recompute_jobs` | ✅ YES | ✅ YES | Job identity tracking for window idempotency |

### Empty Ledger vs Populated Ledger Behavior

**Empty Ledger Scenario**:
- Worker reads events from `attribution_events`
- Computes allocations deterministically
- Writes allocations to `attribution_allocations`
- **No ledger interaction** (ledger may be empty or non-existent)

**Populated Ledger Scenario** (e.g., manual inserts or future B2.2/B2.3):
- Worker **ignores** existing ledger rows
- Reads events from `attribution_events` (same as empty scenario)
- Computes allocations deterministically (same as empty scenario)
- Writes allocations to `attribution_allocations` (same as empty scenario)
- **Ledger rows remain untouched** (no reads, no writes, no FK violations)

**Guarantee**: Worker behavior is **deterministic and identical** regardless of ledger state.

---

## Window-Scoped Idempotency (B0.5.3.2)

### Mechanism

Window-scoped idempotency is enforced via `attribution_recompute_jobs` table with UNIQUE constraint on `(tenant_id, window_start, window_end, model_version)`.

### Behavior

Rerunning the same window `(tenant_id, window_start, window_end, model_version)`:
1. **Reuses existing job identity row** (UPSERT, not INSERT)
2. **Increments `run_count`** for observability
3. **Produces identical allocations** (deterministic baseline proof harness)

### Overwrite Strategy

**Event-scoped overwrite** (not window-scoped):
- Unique constraint: `(tenant_id, event_id, model_version, channel)`
- UPSERT via `ON CONFLICT DO UPDATE`
- Rerunning a window **replaces** allocations for events in that window

**Note**: Window idempotency ensures **job identity** is stable; event-scoped overwrite ensures **allocation values** are deterministic.

---

## Revenue Input Semantics Interaction with Idempotency

### Contract B + Window Idempotency

**Guarantees**:
- ✅ Repeat window runs produce identical allocations (deterministic)
- ✅ No duplicate ledger rows created (worker doesn't write ledger)
- ✅ No cascade deletes (worker doesn't delete allocations, only UPSERTs)
- ✅ Ledger referential integrity preserved (FK remains valid, just unused by worker)

**Edge Cases**:
- **Ledger rows exist from previous runs**: Worker ignores them, recomputes allocations deterministically, ledger rows remain untouched
- **Allocation replacement**: If allocations are recomputed, existing ledger rows referencing those allocations remain valid (FK integrity preserved)
- **Window boundary changes**: New allocations created, old allocations remain (no cascade deletes)

### Non-Circularity Invariant

**Invariant**: The worker does not read from a table whose rows cannot exist without the outputs we're computing.

**Validation**:
- `revenue_ledger.allocation_id` is NOT NULL FK to `attribution_allocations`
- Ledger rows cannot exist without allocations
- Allocations are created by the worker
- **Therefore**: Worker cannot read ledger to compute allocations (circular dependency)

**Contract B satisfies this invariant**: Worker reads from `attribution_events` (upstream) and writes to `attribution_allocations` (downstream), never touching `revenue_ledger` (further downstream).

---

## Future Evolution (B2.2/B2.3)

**Planned Changes** (not in B0.5.3 scope):
- Webhook ingestion will populate `revenue_ledger` via `transaction_id` / `order_id` (upstream keys)
- Reconciliation will match ledger entries to allocations (downstream verification)
- **Contract B remains valid**: Worker still computes allocations from events; ledger is verified separately

**Schema Evolution** (if Contract A desired later):
- Make `allocation_id` nullable OR
- Add upstream keys (`transaction_id`, `order_id`) with proven population path OR
- Redesign FK direction (ledger → events, not ledger → allocations)

**Current Contract**: Contract B (worker ignores ledger) is the **correct choice** for B0.5.3 given schema constraints and roadmap intent.

---

## References

- Evidence Pack: `docs/backend/b0533_revenue_input_evidence.md`
- Worker Code: `backend/app/tasks/attribution.py`
- Schema: `db/schema/live_schema_snapshot.sql` (revenue_ledger table)
- Migration (allocation_id NOT NULL): `alembic/versions/003_data_governance/202511141302_ledger_allocation_id_not_null.py`
