# B0.3 Database Schema Foundation - Forensic Analysis Response

**Document Purpose**: Independent empirical evaluation of Phase B0.3 completion against requirements posed by Engineering Analysts Billy and Alex.

**Methodology**: Evidence-based forensic analysis grounded in:
- Static code analysis of Alembic migration files
- Schema DDL inspection
- Constraint and policy verification
- Index and performance analysis
- First-principles reasoning

**Date**: 2025-11-14  
**Analyst**: AI Assistant (Claude)  
**Scope**: Phase B0.3 Database Schema Foundation

---

## EXECUTIVE SUMMARY

### Migration Lineage
The database schema has evolved through **14 migrations** from baseline:

1. `baseline` (202511121302) - Zero-state baseline
2. `202511131115_add_core_tables` - Core 6 tables created
3. `202511131119_add_materialized_views` - Materialized views for contract compliance
4. `202511131120_add_rls_policies` - RLS policies for tenant isolation
5. `202511131121_add_grants` - Role-based access control
6. `202511131232_enhance_allocation_schema` - Allocation ratio and model version
7. `202511131240_add_sum_equality_validation` - Revenue accounting validation
8. `202511131250_enhance_revenue_ledger` - Allocation-based posting
9. `202511141200_revoke_events_update_delete` - Events immutability (privilege level)
10. `202511141201_add_events_guard_trigger` - Events immutability (trigger level)
11. `202511141300_revoke_ledger_update_delete` - Ledger immutability (privilege level)
12. `202511141301_add_ledger_guard_trigger` - Ledger immutability (trigger level)
13. `202511141302_ledger_allocation_id_not_null` - Ledger traceability enforcement
14. `202511141310_create_channel_taxonomy` - Canonical channel taxonomy table
15. `202511141311_allocations_channel_fk_to_taxonomy` - FK to taxonomy with backfill

### Critical Findings Summary

**PASS**: Core schema completeness (all 6 tables exist)  
**PASS**: RLS policies operational on all tenant-scoped tables  
**PASS**: Immutability enforcement via dual-layer (privilege + trigger)  
**PASS**: Idempotency constraints present  
**PASS**: Channel taxonomy with FK enforcement  
**PARTIAL**: Some indexes present but not all required indexes from Backend Guide  
**GAP IDENTIFIED**: No `api_key_hash` column in tenants table (privacy/auth concern)  
**GAP IDENTIFIED**: Schema diverges from Backend Guide specifications in several areas

---

## CATEGORY A: CORE SCHEMA COMPLETENESS

### Billy Question A-01: Core Five Tables DDL

**Question Restated**: Can you provide the final, committed DDL (e.g., from `pg_dump` or the `001_initial_schema.py` migration) for the five core tables: `tenants`, `attribution_events`, `attribution_allocations`, `revenue_ledger`, and `dead_events`?

**Evidence Source**: `alembic/versions/202511131115_add_core_tables.py` (lines 54-273)

**Answer**: ✅ **CONFIRMED** - All five core tables exist with DDL. However, there are **6 tables, not 5** as the migration also creates `reconciliation_runs`.

#### Table 1: tenants

```sql
CREATE TABLE tenants (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE tenants 
    ADD CONSTRAINT ck_tenants_name_not_empty 
    CHECK (LENGTH(TRIM(name)) > 0);

CREATE INDEX idx_tenants_name ON tenants (name);
```

**Source**: Migration 202511131115, lines 54-71

**CRITICAL GAP IDENTIFIED**: ❌ The Backend Guide specifies `api_key_hash VARCHAR(255) NOT NULL UNIQUE` and `notification_email VARCHAR(255) NOT NULL` but these columns are **MISSING** from the implemented schema. This is a **BLOCKING** issue as it prevents API authentication.

#### Table 2: attribution_events

```sql
CREATE TABLE attribution_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    occurred_at timestamptz NOT NULL,
    external_event_id text,
    correlation_id uuid,
    session_id uuid,
    revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (revenue_cents >= 0),
    raw_payload jsonb NOT NULL
);

-- Idempotency indexes (partial unique)
CREATE UNIQUE INDEX idx_attribution_events_tenant_external_event_id 
    ON attribution_events (tenant_id, external_event_id) 
    WHERE external_event_id IS NOT NULL;

CREATE UNIQUE INDEX idx_attribution_events_tenant_correlation_id 
    ON attribution_events (tenant_id, correlation_id) 
    WHERE correlation_id IS NOT NULL AND external_event_id IS NULL;

-- Performance indexes
CREATE INDEX idx_attribution_events_tenant_occurred_at 
    ON attribution_events (tenant_id, occurred_at DESC);

CREATE INDEX idx_attribution_events_session_id 
    ON attribution_events (session_id) 
    WHERE session_id IS NOT NULL;
```

**Source**: Migration 202511131115, lines 98-142

**SCHEMA DIVERGENCE IDENTIFIED**: ❌ The Backend Guide specifies different column names:
- Backend Guide: `event_timestamp`, `idempotency_key`, `event_type`, `channel`, `campaign_id`, `conversion_value_cents`, `currency`, `processed_at`, `processing_status`, `retry_count`
- Implemented: `occurred_at`, `external_event_id` + `correlation_id` (dual idempotency), NO event_type/channel/campaign_id/etc.

This is a **fundamental schema mismatch** that deviates significantly from Billy and Alex's expectations based on the Backend Guide § 3.1.

#### Table 3: attribution_allocations

```sql
CREATE TABLE attribution_allocations (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    event_id uuid NOT NULL REFERENCES attribution_events(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    channel text NOT NULL,  -- Later renamed to channel_code and FK'd to taxonomy
    allocated_revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (allocated_revenue_cents >= 0),
    model_metadata jsonb,
    correlation_id uuid
);

-- Later enhanced in migration 202511131232 with:
ALTER TABLE attribution_allocations
    ADD COLUMN allocation_ratio numeric(6,5) NOT NULL DEFAULT 0.0;
ALTER TABLE attribution_allocations
    ADD CONSTRAINT ck_attribution_allocations_allocation_ratio_bounds
    CHECK (allocation_ratio >= 0 AND allocation_ratio <= 1);

ALTER TABLE attribution_allocations
    ADD COLUMN model_version text NOT NULL DEFAULT 'unknown';

-- And later in migration 202511141311:
ALTER TABLE attribution_allocations 
    RENAME COLUMN channel TO channel_code;
ALTER TABLE attribution_allocations
    ADD CONSTRAINT fk_attribution_allocations_channel_code
    FOREIGN KEY (channel_code) REFERENCES channel_taxonomy(code);

CREATE INDEX idx_attribution_allocations_tenant_created_at 
    ON attribution_allocations (tenant_id, created_at DESC);
CREATE INDEX idx_attribution_allocations_event_id 
    ON attribution_allocations (event_id);
CREATE INDEX idx_attribution_allocations_channel 
    ON attribution_allocations (channel);
```

**Source**: Migrations 202511131115 (lines 192-226), 202511131232 (lines 48-124), 202511141311 (lines 69-141)

**FINDING**: ✅ Table exists but evolves significantly. Final state includes allocation_ratio, model_version, and channel_code FK to taxonomy.

**CRITICAL GAP**: ❌ Backend Guide specifies `confidence_score NUMERIC(4,3)` with CHECK constraint `(confidence_score >= 0 AND confidence_score <= 1)` but this column is **NOT PRESENT**. Statistical metadata columns (`credible_interval_lower_cents`, `credible_interval_upper_cents`, `convergence_r_hat`, `effective_sample_size`) are also **MISSING**.

#### Table 4: revenue_ledger

```sql
CREATE TABLE revenue_ledger (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (revenue_cents >= 0),
    is_verified boolean NOT NULL DEFAULT false,
    verified_at timestamptz,
    reconciliation_run_id uuid
);

-- Later enhanced in migration 202511131250 with:
ALTER TABLE revenue_ledger
    ADD COLUMN allocation_id uuid REFERENCES attribution_allocations(id) ON DELETE CASCADE;
ALTER TABLE revenue_ledger
    ADD COLUMN posted_at timestamptz NOT NULL DEFAULT now();

-- And in migration 202511141302:
ALTER TABLE revenue_ledger ALTER COLUMN allocation_id SET NOT NULL;

CREATE INDEX idx_revenue_ledger_tenant_updated_at 
    ON revenue_ledger (tenant_id, updated_at DESC);
CREATE INDEX idx_revenue_ledger_is_verified 
    ON revenue_ledger (is_verified) 
    WHERE is_verified = true;
```

**Source**: Migrations 202511131115 (lines 238-268), 202511131250 (lines 46-77), 202511141302 (lines 69)

**CRITICAL GAP**: ❌ Backend Guide specifies state machine columns (`state`, `previous_state`), multi-currency support (`amount_cents`, `currency`, `amount_usd_cents`, `fx_rate_used`, `fx_conversion_timestamp`), and `transaction_id VARCHAR(255) UNIQUE NOT NULL`. None of these columns exist in the implemented schema.

The implemented schema has a completely different design focused on `allocation_id` traceability rather than state machine and multi-currency support.

#### Table 5: dead_events

```sql
CREATE TABLE dead_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    ingested_at timestamptz NOT NULL DEFAULT now(),
    source text NOT NULL,
    error_code text NOT NULL,
    error_detail jsonb NOT NULL,
    raw_payload jsonb NOT NULL,
    correlation_id uuid,
    external_event_id text
);

CREATE INDEX idx_dead_events_tenant_ingested_at 
    ON dead_events (tenant_id, ingested_at DESC);
CREATE INDEX idx_dead_events_source ON dead_events (source);
CREATE INDEX idx_dead_events_error_code ON dead_events (error_code);
```

**Source**: Migration 202511131115, lines 154-181

**FINDING**: ✅ Table exists with error tracking structure.

**SCHEMA DIVERGENCE**: ❌ Backend Guide specifies different column names (`error_type`, `error_message`, `error_traceback`, `retry_count`, `last_retry_at`, `remediation_status`). Implemented uses `error_code`, `error_detail`, NO retry tracking columns.

#### Table 6: reconciliation_runs (Extra Table)

```sql
CREATE TABLE reconciliation_runs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    last_run_at timestamptz NOT NULL,
    state VARCHAR(20) NOT NULL DEFAULT 'idle' 
        CHECK (state IN ('idle', 'running', 'failed', 'completed')),
    error_message text,
    run_metadata jsonb
);

CREATE INDEX idx_reconciliation_runs_tenant_last_run_at 
    ON reconciliation_runs (tenant_id, last_run_at DESC);
CREATE INDEX idx_reconciliation_runs_state 
    ON reconciliation_runs (state);
```

**Source**: Migration 202511131115, lines 274-308

**FINDING**: ✅ Table exists, not mentioned in Billy/Alex's Backend Guide references but appears to be a valid addition for reconciliation tracking.

**Acceptance Criteria Assessment**:
- ❌ FAILED: Schema does NOT match Backend Guide § 3.1 specifications
- ✅ PASS: All tables use UUID PKs with gen_random_uuid()
- ✅ PASS: TIMESTAMPTZ with now() defaults present
- ❌ FAILED: Many expected columns missing (api_key_hash, idempotency_key, event_type, channel, confidence_score, transaction_id, state, currency fields, etc.)

**Architectural Impact**: **BLOCKING** - The implemented schema is fundamentally different from the Backend Guide specifications. B0.4 (Ingestion) cannot be built as specified because key columns are missing.

---

### Billy Question A-02: Materialized Views DDL

**Question Restated**: Can you provide the DDL from `002_materialized_views.py` that defines `mv_channel_performance` and `mv_daily_revenue_summary`?

**Evidence Source**: `alembic/versions/202511131119_add_materialized_views.py`

**Answer**: ❌ **DISCREPANCY IDENTIFIED** - The migration creates materialized views, but with DIFFERENT NAMES than specified:

#### Materialized View 1: mv_realtime_revenue (NOT mv_channel_performance)

```sql
CREATE MATERIALIZED VIEW mv_realtime_revenue AS
SELECT 
    rl.tenant_id,
    COALESCE(SUM(rl.revenue_cents), 0) / 100.0 AS total_revenue,
    BOOL_OR(rl.is_verified) AS verified,
    EXTRACT(EPOCH FROM (now() - MAX(rl.updated_at)))::INTEGER AS data_freshness_seconds
FROM revenue_ledger rl
GROUP BY rl.tenant_id;

CREATE UNIQUE INDEX idx_mv_realtime_revenue_tenant_id 
    ON mv_realtime_revenue (tenant_id);
```

**Source**: Migration 202511131119, lines 45-59

**FINDING**: ✅ Materialized view exists with unique index, BUT it's **NOT** named `mv_channel_performance`. This is a revenue aggregate view, not a channel performance view.

#### Materialized View 2: mv_reconciliation_status (NOT mv_daily_revenue_summary)

```sql
CREATE MATERIALIZED VIEW mv_reconciliation_status AS
SELECT 
    rr.tenant_id,
    rr.state,
    rr.last_run_at,
    rr.id AS reconciliation_run_id
FROM reconciliation_runs rr
INNER JOIN (
    SELECT tenant_id, MAX(last_run_at) AS max_last_run_at
    FROM reconciliation_runs
    GROUP BY tenant_id
) latest ON rr.tenant_id = latest.tenant_id 
    AND rr.last_run_at = latest.max_last_run_at;

CREATE UNIQUE INDEX idx_mv_reconciliation_status_tenant_id 
    ON mv_reconciliation_status (tenant_id);
```

**Source**: Migration 202511131119, lines 66-86

**FINDING**: ✅ Materialized view exists with unique index, BUT it's **NOT** named `mv_daily_revenue_summary`. This is a reconciliation status view, not a daily revenue summary.

**Acceptance Criteria Assessment**:
- ❌ FAILED: `mv_channel_performance` does NOT exist
- ❌ FAILED: `mv_daily_revenue_summary` does NOT exist
- ✅ PASS: Two materialized views exist with unique indexes
- ❌ FAILED: The views that DO exist have different names and purposes than specified

**Architectural Impact**: **HIGH** - B2.6 (Attribution API Endpoints) expecting `mv_channel_performance` will not find it. Dashboard queries for channel performance will need to be rewritten to query base tables or create the missing view.

---

### Alex Questions A1-A6: Detailed Table Structure Verification

#### Alex A1: Tenants Table Structure Verification

**Question Restated**: Please provide the complete DDL for the `tenants` table including: (1) Exact column definitions, (2) Default value implementations for `created_at` and `updated_at`, (3) UNIQUE constraint on `api_key_hash`.

**Answer**: Already provided in Billy A-01 analysis above.

**CRITICAL FINDING**: ❌ **FAILED** - `api_key_hash` column does NOT exist. `notification_email` column does NOT exist. This represents a **BLOCKING** gap for API authentication (B0.4 cannot authenticate tenants).

#### Alex A2: Attribution Events Table Completeness

**Question Restated**: Provide the full `attribution_events` table DDL showing all 13+ required columns and FK constraints.

**Answer**: Already provided in Billy A-01 analysis above.

**CRITICAL FINDING**: ❌ **FAILED** - Implemented schema has only 10 columns, missing: `idempotency_key` (has `external_event_id` + `correlation_id` instead), `event_type`, `channel`, `campaign_id`, `conversion_value_cents`, `currency`, `processed_at`, `processing_status`, `retry_count`.

**Actual Columns Present**:
1. `id` ✅
2. `tenant_id` ✅
3. `created_at` ✅
4. `updated_at` ✅
5. `occurred_at` (equivalent to `event_timestamp`) ✅
6. `external_event_id` (alternative to `idempotency_key`) ⚠️
7. `correlation_id` (additional idempotency mechanism) ⚠️
8. `session_id` ✅
9. `revenue_cents` (NOT `conversion_value_cents`) ⚠️
10. `raw_payload` ✅

**Missing Columns**:
- `event_type` ❌ (BLOCKING for event classification)
- `channel` ❌ (BLOCKING for attribution logic)
- `campaign_id` ❌ (HIGH impact for campaign tracking)
- `currency` ❌ (BLOCKING for multi-currency support)
- `processed_at` ❌ (HIGH impact for processing tracking)
- `processing_status` ❌ (BLOCKING for background worker queue)
- `retry_count` ❌ (MODERATE impact for retry logic)

**Architectural Impact**: **BLOCKING** - Without `event_type` and `channel`, B0.4 ingestion service cannot store this essential attribution data. Background workers (B0.5) cannot query for `processing_status = 'pending'` events.

#### Alex A3: Attribution Allocations Table Structure

**Question Restated**: Provide DDL for `attribution_allocations` including statistical metadata columns, CHECK constraint on `confidence_score`, FK to `attribution_events`, and verification columns.

**Answer**: Already provided in Billy A-01 analysis above with additional findings:

**CRITICAL FINDING**: ❌ **FAILED** - Statistical metadata columns are completely MISSING:
- `confidence_score` ❌ (BLOCKING for statistical attribution)
- `credible_interval_lower_cents` ❌
- `credible_interval_upper_cents` ❌
- `convergence_r_hat` ❌
- `effective_sample_size` ❌

**Verification Columns**: Also MISSING:
- `verified` ❌
- `verification_source` ❌
- `verification_timestamp` ❌

**What EXISTS Instead**:
- `allocation_ratio` ✅ (numeric(6,5) with CHECK 0-1) - Similar purpose to confidence_score but different semantics
- `model_version` ✅ (text NOT NULL)
- `model_metadata` ✅ (jsonb) - Could theoretically store statistical metadata

**Architectural Impact**: **BLOCKING** - B2.1 (Attribution Models) expects to write `confidence_score` and statistical metadata. B2.4 (Revenue Verification) expects to update `verified` columns. The schema provides `allocation_ratio` instead, which serves a related but different purpose (proportion of revenue, not statistical confidence).

#### Alex A4: Revenue Ledger Schema Validation

**Question Restated**: Provide `revenue_ledger` table DDL showing state machine columns, multi-currency support, verification metadata, and UNIQUE constraint on `transaction_id`.

**Answer**: Already provided in Billy A-01 analysis above with additional findings:

**CRITICAL FINDING**: ❌ **FAILED** - Multi-currency and state machine design is completely MISSING:

**Missing State Machine**:
- `state` ❌ (BLOCKING for refund tracking)
- `previous_state` ❌

**Missing Multi-Currency Support**:
- `transaction_id` ❌ (BLOCKING for idempotency)
- `amount_cents` ❌ (uses `revenue_cents` instead)
- `currency` ❌ (BLOCKING for FX conversion)
- `amount_usd_cents` ❌ (BLOCKING for normalized reporting)
- `fx_rate_used` ❌ (BLOCKING for audit trail)
- `fx_conversion_timestamp` ❌

**What EXISTS Instead**:
- `revenue_cents` ✅ (INTEGER NOT NULL)
- `is_verified` ✅ (boolean, similar to state but less granular)
- `verified_at` ✅ (timestamptz)
- `allocation_id` ✅ (uuid FK, NOT NULL - added in later migrations)
- `posted_at` ✅ (timestamptz - added in later migration)
- `reconciliation_run_id` ✅ (uuid)

**Design Philosophy Difference**: The implemented schema uses `allocation_id` as primary key for traceability, whereas Backend Guide uses `transaction_id` for webhook transaction deduplication. These serve different purposes.

**Architectural Impact**: **BLOCKING** - B2.2 (Webhook Ingestion) expects to use `transaction_id` for deduplication. B2.3 (Currency Conversion) expects `currency` and USD normalization fields. B2.4 (Refund Handling) expects state machine columns. None of this infrastructure exists.

#### Alex A5: Dead Events Table for Error Handling

**Question Restated**: Provide `dead_events` table DDL with error classification columns, retry logic columns, preserved raw_payload, and index on remediation_status.

**Answer**: Already provided in Billy A-01 analysis above with additional findings:

**PARTIAL FINDING**: ⚠️ **PARTIALLY IMPLEMENTED** - Error tracking exists but retry logic is missing:

**What EXISTS**:
- `error_code` ✅ (text NOT NULL) - Similar to `error_type`
- `error_detail` ✅ (jsonb NOT NULL) - Similar to `error_message` but structured
- `raw_payload` ✅ (jsonb NOT NULL)
- `source` ✅ (text NOT NULL) - Good addition
- Index on `error_code` ✅

**Missing Retry Logic**:
- `error_traceback` ❌ (error_detail jsonb likely contains this)
- `retry_count` ❌ (MODERATE impact for retry limits)
- `last_retry_at` ❌ (MODERATE impact for retry scheduling)
- `remediation_status` ❌ (MODERATE impact for background processing)
- Index on `remediation_status` ❌ (specified as `idx_dead_events_remediation`)

**Architectural Impact**: **MODERATE** - B0.5 (Background Workers) will need to implement retry logic without database-level retry tracking. The `error_detail` jsonb can likely compensate for missing `error_traceback`.

#### Alex A6: Revenue State Transitions Audit Table

**Question Restated**: Confirm existence of `revenue_state_transitions` table with FK to `revenue_ledger`, state change tracking, and timestamp.

**Answer**: ❌ **TABLE DOES NOT EXIST**

**Evidence Source**: Comprehensive review of all 14 migration files found NO creation of `revenue_state_transitions` table.

**Architectural Impact**: **MODERATE** - Refund audit trail (B2.4) will not have a dedicated transitions table. Without `state` columns in `revenue_ledger`, there's no state to transition anyway. This is consistent with the different design approach taken.

---

### Category A Summary

**Verdict**: ❌ **FAILED** - Core schema exists but is **fundamentally different** from Backend Guide specifications.

**Core Tables**: 6/5 exist (extra `reconciliation_runs` table)  
**Materialized Views**: 2/2 exist but with wrong names and purposes  
**Column Coverage**: ~40% of expected columns present  
**Schema Philosophy**: Diverges from Backend Guide - uses allocation-based traceability instead of transaction-based webhook deduplication and state machines

**Recommendation**: This represents a **DESIGN FORK**, not incomplete implementation. Either:
1. The Backend Guide is outdated and should be updated to reflect actual implementation, OR
2. The implementation needs significant rework to match Backend Guide specifications

---

## CATEGORY B: CONSTRAINT INTEGRITY

### Billy Question B-01: Confidence Score CHECK Constraint

**Question Restated**: Can you provide the DDL fragment that implements the `CHECK (confidence_score >= 0 AND confidence_score <= 1)` constraint on `attribution_allocations`?

**Answer**: ❌ **DOES NOT EXIST** - The `confidence_score` column itself does not exist.

**What EXISTS Instead**:

```sql
ALTER TABLE attribution_allocations
    ADD CONSTRAINT ck_attribution_allocations_allocation_ratio_bounds
    CHECK (allocation_ratio >= 0 AND allocation_ratio <= 1);
```

**Source**: Migration 202511131232, lines 54-57

**FINDING**: ✅ A similar CHECK constraint exists for `allocation_ratio` (numeric(6,5)) with the same 0-1 bounds. However, `allocation_ratio` represents "proportion of event revenue" whereas `confidence_score` represents "statistical confidence". These are semantically different.

**Architectural Impact**: **BLOCKING** - B2.1 (Attribution Models) expecting to write `confidence_score` will fail. The `allocation_ratio` constraint provides similar data quality enforcement but for a different metric.

---

### Billy Question B-02: Foreign Key Constraints and ON DELETE Policies

**Question Restated**: Provide evidence of FK constraints and their `ON DELETE` policies, specifically: (1) `attribution_allocations(event_id)` → `attribution_events(id)`, (2) `revenue_state_transitions(ledger_id)` → `revenue_ledger(id)`.

**Answer**: 

#### FK #1: attribution_allocations.event_id → attribution_events.id

```sql
CREATE TABLE attribution_allocations (
    event_id uuid NOT NULL REFERENCES attribution_events(id) ON DELETE CASCADE,
    ...
);
```

**Source**: Migration 202511131115, line 197

**FINDING**: ✅ **CONFIRMED** - FK exists with `ON DELETE CASCADE`

**DISCREPANCY**: ❌ Backend Guide specifies `ON DELETE SET NULL` for this relationship (to preserve allocations for audit even if event is deleted). Implemented uses `ON DELETE CASCADE` which will delete allocations when event is deleted.

**Architectural Impact**: **MODERATE** - Deleting an event will cascade delete all its allocations, losing attribution history. Backend Guide's `SET NULL` approach preserves allocations for post-mortem analysis.

#### FK #2: revenue_state_transitions.ledger_id → revenue_ledger.id

**Answer**: ❌ **TABLE DOES NOT EXIST** - The `revenue_state_transitions` table was never created, so this FK cannot exist.

---

### Billy Question B-03: NOT NULL Constraints Verification

**Question Restated**: Can you confirm that key columns in `attribution_events` (`tenant_id`, `session_id`, `event_type`, `channel`, `idempotency_key`, `raw_payload`) are set to `NOT NULL`?

**Answer**: **PARTIALLY** - Some columns exist with NOT NULL, others don't exist at all.

**Columns with NOT NULL** (✅):
- `tenant_id uuid NOT NULL` ✅
- `session_id uuid` ❌ **NULLABLE** (Privacy violation risk!)
- `raw_payload jsonb NOT NULL` ✅
- `occurred_at timestamptz NOT NULL` ✅ (similar to event_timestamp)
- `revenue_cents INTEGER NOT NULL` ✅

**Columns MISSING** (❌):
- `event_type` ❌ Does not exist
- `channel` ❌ Does not exist
- `idempotency_key` ❌ Does not exist (has `external_event_id text` which is **NULLABLE**)

**Source**: Migration 202511131115, lines 100-111

**CRITICAL FINDING**: ❌ `session_id` is **NULLABLE**, which violates Backend Guide requirement. This breaks session-scoped attribution if NULL values are allowed.

**Architectural Impact**: **HIGH** - Nullable `session_id` allows events without session context, breaking privacy-first architecture. Nullable `external_event_id` weakens idempotency enforcement (though dual mechanism with `correlation_id` provides backup).

---

### Alex Question B1: Foreign Key Constraint Verification (SQL Query Results)

**Question Restated**: Provide output of SQL query showing all FK relationships and their `ON DELETE` rules.

**Answer**: ✅ **DOCUMENTED** - Based on migration DDL analysis:

| table_name | column_name | foreign_table_name | foreign_column_name | delete_rule |
|---|---|---|---|---|
| attribution_events | tenant_id | tenants | id | CASCADE |
| dead_events | tenant_id | tenants | id | CASCADE |
| attribution_allocations | tenant_id | tenants | id | CASCADE |
| attribution_allocations | event_id | attribution_events | id | CASCADE |
| revenue_ledger | tenant_id | tenants | id | CASCADE |
| revenue_ledger | allocation_id | attribution_allocations | id | CASCADE |
| reconciliation_runs | tenant_id | tenants | id | CASCADE |

**Source**: Migrations 202511131115, 202511131250

**Acceptance Criteria Assessment**:
- ✅ PASS: `attribution_events.tenant_id → tenants.id` with `ON DELETE CASCADE`
- ✅ PASS: `attribution_allocations.tenant_id → tenants.id` with `ON DELETE CASCADE`
- ❌ FAILED: `attribution_allocations.event_id → attribution_events.id` has `CASCADE` not `SET NULL`
- ✅ PASS: `revenue_ledger.tenant_id → tenants.id` with `ON DELETE CASCADE`
- ✅ PASS: `dead_events.tenant_id → tenants.id` with `ON DELETE CASCADE`
- ❌ N/A: `revenue_state_transitions` table does not exist

**Architectural Impact**: **MODERATE** - All tenant FKs correctly CASCADE (GDPR "Right to be Forgotten"). Allocation FK uses CASCADE instead of SET NULL, losing audit trail on event deletion.

---

### Alex Question B2: Unique Constraint Validation

**Question Restated**: Provide results of SQL query showing UNIQUE constraints on `tenants.api_key_hash`, `attribution_events.idempotency_key`, and `revenue_ledger.transaction_id`.

**Answer**: ❌ **MOSTLY MISSING** - Only alternative mechanisms exist:

| table_name | column_name | constraint_name | constraint_type |
|---|---|---|---|
| attribution_events | (tenant_id, external_event_id) | idx_attribution_events_tenant_external_event_id | UNIQUE (Partial) |
| attribution_events | (tenant_id, correlation_id) | idx_attribution_events_tenant_correlation_id | UNIQUE (Partial) |
| attribution_allocations | (tenant_id, event_id, model_version, channel_code) | idx_attribution_allocations_tenant_event_model_channel | UNIQUE (Partial) |
| revenue_ledger | (tenant_id, allocation_id) | idx_revenue_ledger_tenant_allocation_id | UNIQUE (Partial) |

**Source**: Migrations 202511131115, 202511131232, 202511131250

**Acceptance Criteria Assessment**:
- ❌ FAILED: `tenants.api_key_hash` - Column does not exist
- ❌ FAILED: `attribution_events.idempotency_key` - Column does not exist; alternative partial unique indexes on (tenant_id, external_event_id) and (tenant_id, correlation_id) provide idempotency
- ❌ FAILED: `revenue_ledger.transaction_id` - Column does not exist; alternative partial unique index on (tenant_id, allocation_id) provides different idempotency mechanism

**Architectural Impact**: **CRITICAL** - Idempotency is enforced but through different mechanisms. Backend Guide expects single-column unique constraints; implementation uses composite partial unique indexes. This is architecturally valid but incompatible with expected API contracts.

---

### Alex Question B3: Check Constraint Enforcement

**Question Restated**: Provide CHECK constraint definitions for `confidence_score` on `attribution_allocations`.

**Answer**: ❌ **DOES NOT EXIST** - Covered in Billy B-01. `allocation_ratio` CHECK exists instead.

---

### Alex Question B4: NOT NULL Constraint Audit

**Question Restated**: Provide output showing all NOT NULL columns in `attribution_events`, `attribution_allocations`, and `revenue_ledger`.

**Answer**: ✅ **DOCUMENTED** - Based on migration DDL analysis:

#### attribution_events NOT NULL columns:
1. `id` ✅
2. `tenant_id` ✅
3. `created_at` ✅
4. `updated_at` ✅
5. `occurred_at` ✅
6. `revenue_cents` ✅ (NOT NULL with DEFAULT 0)
7. `raw_payload` ✅

**NULLABLE** (Privacy/Quality Risk):
- `session_id` ❌ (Should be NOT NULL for session-scoped attribution)
- `external_event_id` ❌ (Idempotency weakness)
- `correlation_id` ❌ (Alternative idempotency mechanism)

#### attribution_allocations NOT NULL columns:
1. `id` ✅
2. `tenant_id` ✅
3. `event_id` ✅
4. `created_at` ✅
5. `updated_at` ✅
6. `channel_code` ✅ (originally `channel`)
7. `allocated_revenue_cents` ✅
8. `allocation_ratio` ✅ (added in migration 202511131232)
9. `model_version` ✅ (added in migration 202511131232, DEFAULT 'unknown')

**NULLABLE**:
- `model_metadata` (jsonb) - Acceptable
- `correlation_id` - Acceptable

#### revenue_ledger NOT NULL columns:
1. `id` ✅
2. `tenant_id` ✅
3. `created_at` ✅
4. `updated_at` ✅
5. `revenue_cents` ✅
6. `is_verified` ✅ (DEFAULT false)
7. `posted_at` ✅ (added in migration 202511131250, DEFAULT now())
8. `allocation_id` ✅ (added as nullable in 202511131250, made NOT NULL in 202511141302)

**NULLABLE**:
- `verified_at` - Acceptable (only set when verified)
- `reconciliation_run_id` - Acceptable

**Architectural Impact**: **HIGH** - Missing NOT NULL on `session_id` is a privacy violation risk. Missing NOT NULL on `external_event_id` weakens idempotency (though dual mechanism with `correlation_id` compensates).

---

### Category B Summary

**Verdict**: ⚠️ **PARTIALLY IMPLEMENTED** - Constraints exist but for different columns than specified.

**CHECK Constraints**: allocation_ratio has CHECK (0-1), but confidence_score does not exist  
**Foreign Keys**: All present with correct tenant CASCADE, but allocations use CASCADE instead of SET NULL  
**Unique Constraints**: Different mechanisms used (composite partial indexes instead of single-column UNIQUE)  
**NOT NULL**: Mostly present, but critical gaps: session_id is NULLABLE

**Recommendation**: Constraint integrity is adequate for the implemented schema design, but does not match Backend Guide expectations.

---

## CATEGORY C: TENANT ISOLATION & SECURITY

### Billy Question C-01: RLS Policy DDL for attribution_events

**Question Restated**: Can you provide the *exact* DDL for the `tenant_isolation_policy` and the command that *enables* RLS on `attribution_events`?

**Answer**: ✅ **CONFIRMED** - RLS is fully implemented.

```sql
-- Enable RLS
ALTER TABLE attribution_events ENABLE ROW LEVEL SECURITY;

-- Force RLS (prevents bypass even for table owners)
ALTER TABLE attribution_events FORCE ROW LEVEL SECURITY;

-- Create tenant isolation policy
CREATE POLICY tenant_isolation_policy ON attribution_events
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);
```

**Source**: Migration 202511131120, lines 59-71

**Acceptance Criteria Assessment**:
- ✅ PASS: Policy predicate is `USING (tenant_id = current_setting('app.current_tenant_id')::uuid)` - EXACT MATCH
- ✅ PASS: `ALTER TABLE attribution_events ENABLE ROW LEVEL SECURITY` command present
- ✅ PASS: `FORCE ROW LEVEL SECURITY` also applied (defense-in-depth, prevents owner bypass)

**Architectural Impact**: ✅ **EXCELLENT** - Tenant isolation is correctly implemented with defense-in-depth (FORCE RLS).

---

### Billy Question C-02: RLS Policy Status for Other Tables

**Question Restated**: What is the RLS implementation status for `attribution_allocations`, `revenue_ledger`, and `dead_events`?

**Answer**: ✅ **FULLY IMPLEMENTED** - All tenant-scoped tables have RLS.

**RLS-Protected Tables**:
1. `attribution_events` ✅
2. `attribution_allocations` ✅
3. `revenue_ledger` ✅
4. `dead_events` ✅
5. `reconciliation_runs` ✅

```sql
-- Applied to ALL tenant-scoped tables via loop in migration 202511131120
for table_name in TENANT_SCOPED_TABLES:
    ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY
    ALTER TABLE {table_name} FORCE ROW LEVEL SECURITY
    
    CREATE POLICY tenant_isolation_policy ON {table_name}
        USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
        WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid)
```

**Source**: Migration 202511131120, lines 39-77

**Acceptance Criteria Assessment**:
- ✅ PASS: `attribution_allocations` has RLS enabled with tenant_isolation_policy
- ✅ PASS: `revenue_ledger` has RLS enabled with tenant_isolation_policy
- ✅ PASS: `dead_events` has RLS enabled with tenant_isolation_policy
- ✅ PASS: All policies use identical predicate structure
- ✅ PASS: `FORCE ROW LEVEL SECURITY` applied to all tables

**Architectural Impact**: ✅ **EXCELLENT** - Comprehensive tenant isolation enforced across all tenant-scoped tables. No gaps.

---

### Billy Question C-03: ON DELETE CASCADE for tenant_id FKs

**Question Restated**: Can you confirm `ON DELETE CASCADE` policy is implemented for *all* tables that reference `tenants(id)`?

**Answer**: ✅ **CONFIRMED** - All tenant_id FKs use `ON DELETE CASCADE`.

**Evidence**:

```sql
-- attribution_events
tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE

-- attribution_allocations  
tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE

-- revenue_ledger
tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE

-- dead_events
tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE

-- reconciliation_runs
tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE
```

**Source**: Migration 202511131115, lines 102, 158, 196, 242, 278

**Acceptance Criteria Assessment**:
- ✅ PASS: `attribution_events` has `ON DELETE CASCADE`
- ✅ PASS: `attribution_allocations` has `ON DELETE CASCADE`
- ✅ PASS: `revenue_ledger` has `ON DELETE CASCADE`
- ✅ PASS: `dead_events` has `ON DELETE CASCADE`
- ✅ PASS: `reconciliation_runs` has `ON DELETE CASCADE`

**Architectural Impact**: ✅ **EXCELLENT** - GDPR "Right to be Forgotten" fully supported. Tenant deletion will cascade delete all associated data automatically.

---

### Alex Questions C1-C4: Detailed Security Analysis

#### Alex C1: Row-Level Security Policy Verification (SQL Query)

**Question Restated**: Provide output of `pg_policies` query showing RLS policies.

**Answer**: ✅ **DOCUMENTED** - Based on migration DDL analysis:

| tablename | policyname | roles | cmd | qual | with_check |
|---|---|---|---|---|---|
| attribution_events | tenant_isolation_policy | ALL | ALL | tenant_id = current_setting('app.current_tenant_id')::uuid | tenant_id = current_setting('app.current_tenant_id')::uuid |
| attribution_allocations | tenant_isolation_policy | ALL | ALL | tenant_id = current_setting('app.current_tenant_id')::uuid | tenant_id = current_setting('app.current_tenant_id')::uuid |
| revenue_ledger | tenant_isolation_policy | ALL | ALL | tenant_id = current_setting('app.current_tenant_id')::uuid | tenant_id = current_setting('app.current_tenant_id')::uuid |
| dead_events | tenant_isolation_policy | ALL | ALL | tenant_id = current_setting('app.current_tenant_id')::uuid | tenant_id = current_setting('app.current_tenant_id')::uuid |
| reconciliation_runs | tenant_isolation_policy | ALL | ALL | tenant_id = current_setting('app.current_tenant_id')::uuid | tenant_id = current_setting('app.current_tenant_id')::uuid |

**Source**: Migration 202511131120, lines 67-71

**Acceptance Criteria Assessment**:
- ✅ PASS: Policies exist on all four expected tables (plus reconciliation_runs)
- ✅ PASS: Policy predicate uses `current_setting('app.current_tenant_id')::UUID`
- ✅ PASS: Applies to ALL commands (SELECT, INSERT, UPDATE, DELETE)
- ✅ PASS: Both `USING` and `WITH CHECK` clauses present (for SELECT/UPDATE/DELETE and INSERT respectively)

**Architectural Impact**: ✅ **EXCELLENT** - Product Vision's multi-tenant isolation mandate is fully satisfied.

---

#### Alex C2: RLS Policy Enablement Status (pg_tables Query)

**Question Restated**: Confirm RLS is enabled on all tenant-scoped tables via `pg_tables.rowsecurity` column.

**Answer**: ✅ **CONFIRMED** - Based on migration DDL:

| tablename | rowsecurity |
|---|---|
| attribution_events | true |
| attribution_allocations | true |
| revenue_ledger | true |
| dead_events | true |
| reconciliation_runs | true |

**Source**: Migration 202511131120, lines 61-64 (ENABLE + FORCE ROW LEVEL SECURITY)

**Architectural Impact**: ✅ **EXCELLENT** - All tenant-scoped tables have RLS actively enforced.

---

#### Alex C3: Tenant ID Propagation Mechanism

**Question Restated**: Describe the mechanism for setting `app.current_tenant_id` session variable.

**Answer**: ⚠️ **MECHANISM NOT EVIDENT IN SCHEMA** - The database schema is RLS-ready, but application-layer tenant_id propagation logic is not present in migration files.

**What Schema Provides**:
- RLS policies reference `current_setting('app.current_tenant_id')::UUID` ✅
- Policies are configured to FORCE RLS (no bypass) ✅
- All tenant-scoped tables have tenant_id column ✅

**What Is MISSING from Migration Files**:
- Application middleware code that extracts tenant_id from JWT ❌
- `SET LOCAL app.current_tenant_id = '<uuid>'` execution logic ❌
- Request lifecycle integration (e.g., FastAPI dependency injection) ❌

**Expected Implementation** (not verified in codebase):
```python
# Hypothetical application code (NOT FOUND in schema migrations)
@app.middleware("http")
async def set_tenant_context(request, call_next):
    tenant_id = extract_from_jwt(request.headers["Authorization"])
    await db.execute("SET LOCAL app.current_tenant_id = %s", tenant_id)
    response = await call_next(request)
    return response
```

**Acceptance Criteria Assessment**:
- ⚠️ PARTIAL: RLS policies are configured correctly, but tenant_id propagation mechanism is out-of-scope for B0.3 (database schema phase)
- ⚠️ DEFERRED: This is a B0.4 (Ingestion Service) or B1.x (Authentication/Authorization) responsibility

**Architectural Impact**: ⚠️ **DEFERRED TO FUTURE PHASES** - RLS infrastructure is complete at database level. Application-layer implementation is required but not verifiable in B0.3 scope.

---

#### Alex C4: CASCADE Delete Behavior Validation

**Question Restated**: Execute test query to confirm CASCADE behavior deletes related records.

**Answer**: ✅ **LOGICALLY CONFIRMED** - DDL analysis confirms CASCADE behavior. Test query execution deferred to QA/integration testing.

**Evidence**: All tenant_id FKs use `ON DELETE CASCADE` (covered in Billy C-03 and Alex B1).

**Expected Test Result** (not executed):
```sql
-- Setup test tenant and data
INSERT INTO tenants (id, name) VALUES ('00000000-0000-0000-0000-000000000001', 'Test');
INSERT INTO attribution_events (id, tenant_id, session_id, occurred_at, revenue_cents, raw_payload)
VALUES ('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-000000000001', 
        '00000000-0000-0000-0000-000000000003', NOW(), 100, '{}');

-- Verify CASCADE: Should delete event
DELETE FROM tenants WHERE id = '00000000-0000-0000-0000-000000000001';

-- Check orphaned events
SELECT COUNT(*) FROM attribution_events WHERE tenant_id = '00000000-0000-0000-0000-000000000001';
-- Expected: 0
```

**Acceptance Criteria Assessment**:
- ✅ PASS: DDL confirms CASCADE behavior
- ⚠️ DEFERRED: Execution of validation query requires live database (integration testing scope)

**Architectural Impact**: ✅ **LOGICALLY SOUND** - CASCADE delete will work as specified based on DDL.

---

### Category C Summary

**Verdict**: ✅ **FULLY IMPLEMENTED** - Tenant isolation and security are **exemplary**.

**RLS Policies**: Applied to all 5 tenant-scoped tables ✅  
**RLS Enablement**: ENABLE + FORCE on all tables ✅  
**CASCADE Delete**: All tenant_id FKs use ON DELETE CASCADE ✅  
**Tenant Propagation**: Database infrastructure ready; application logic deferred to future phases ⚠️

**Recommendation**: Category C is **production-ready** at the database schema level. This is the **strongest** aspect of the B0.3 implementation.

---

## CATEGORY D: PERFORMANCE & INDEXING

### Summary of All Indexes Created

**Evidence Source**: Comprehensive review of migrations 202511131115, 202511131119, 202511131232, 202511131250

#### attribution_events indexes:
1. `idx_attribution_events_tenant_external_event_id` - UNIQUE partial on (tenant_id, external_event_id) WHERE NOT NULL ✅
2. `idx_attribution_events_tenant_correlation_id` - UNIQUE partial on (tenant_id, correlation_id) WHERE correlation_id NOT NULL AND external_event_id IS NULL ✅
3. `idx_attribution_events_tenant_occurred_at` - (tenant_id, occurred_at DESC) ✅
4. `idx_attribution_events_session_id` - partial on (session_id) WHERE NOT NULL ✅

#### attribution_allocations indexes:
1. `idx_attribution_allocations_tenant_created_at` - (tenant_id, created_at DESC) ✅
2. `idx_attribution_allocations_event_id` - (event_id) ✅
3. `idx_attribution_allocations_channel` - (channel) ✅
4. `idx_attribution_allocations_tenant_event_model_channel` - UNIQUE partial on (tenant_id, event_id, model_version, channel_code) ✅
5. `idx_attribution_allocations_tenant_model_version` - (tenant_id, model_version) ✅

#### revenue_ledger indexes:
1. `idx_revenue_ledger_tenant_updated_at` - (tenant_id, updated_at DESC) ✅
2. `idx_revenue_ledger_is_verified` - partial on (is_verified) WHERE is_verified = true ✅
3. `idx_revenue_ledger_tenant_allocation_id` - UNIQUE partial on (tenant_id, allocation_id) WHERE NOT NULL ✅

#### dead_events indexes:
1. `idx_dead_events_tenant_ingested_at` - (tenant_id, ingested_at DESC) ✅
2. `idx_dead_events_source` - (source) ✅
3. `idx_dead_events_error_code` - (error_code) ✅

#### reconciliation_runs indexes:
1. `idx_reconciliation_runs_tenant_last_run_at` - (tenant_id, last_run_at DESC) ✅
2. `idx_reconciliation_runs_state` - (state) ✅

#### Materialized view indexes:
1. `idx_mv_realtime_revenue_tenant_id` - UNIQUE on (tenant_id) ✅
2. `idx_mv_reconciliation_status_tenant_id` - UNIQUE on (tenant_id) ✅
3. `idx_mv_allocation_summary_key` - UNIQUE on (tenant_id, event_id, model_version) ✅
4. `idx_mv_allocation_summary_drift` - partial on (drift_cents) WHERE drift_cents > 1 ✅

### Billy Question D-01: Partial Index for Pending Events

**Question Restated**: Can you provide the DDL for the *partial index* `idx_events_processing_status` on `attribution_events(processing_status, processed_at)`?

**Answer**: ❌ **DOES NOT EXIST** - The columns `processing_status` and `processed_at` do not exist in the implemented schema.

**Architectural Impact**: **BLOCKING** - B0.5 (Background Workers) cannot efficiently query for pending events without this index and the underlying columns.

### Billy Question D-02: Composite Index for Dashboard Queries

**Question Restated**: Can you provide the DDL for `idx_allocations_channel_performance` on `attribution_allocations`?

**Answer**: ❌ **DOES NOT EXIST** - No index with this exact name exists.

**Similar Indexes That DO Exist**:
- `idx_attribution_allocations_channel` - single column index on channel ⚠️
- `idx_attribution_allocations_tenant_created_at` - composite on (tenant_id, created_at DESC) ⚠️

**Expected (from Backend Guide)**:
```sql
CREATE INDEX idx_allocations_channel_performance 
    ON attribution_allocations (tenant_id, channel, created_at DESC) 
    INCLUDE (allocated_revenue_cents, confidence_score);
```

**What We Have** (partial coverage):
- Separate indexes for channel and tenant_id+created_at
- NO covering index with INCLUDE clause
- `confidence_score` column doesn't exist anyway

**Architectural Impact**: **HIGH** - Dashboard queries for channel performance will require multiple index lookups and table access, degrading p95 latency from <50ms to potentially >500ms.

### Billy Question D-03: EXPLAIN ANALYZE for Index Usage

**Question Restated**: Can you provide the `EXPLAIN ANALYZE` output for a query that *uses* the `idx_events_tenant_timestamp` index?

**Answer**: ⚠️ **INDEX NAME MISMATCH** - No index named `idx_events_tenant_timestamp` exists. The equivalent index is `idx_attribution_events_tenant_occurred_at`.

**Equivalent Query** (not executed):
```sql
EXPLAIN ANALYZE
SELECT * FROM attribution_events 
WHERE tenant_id = '00000000-0000-0000-0000-000000000001' 
  AND occurred_at >= NOW() - INTERVAL '30 days';
```

**Expected Plan** (based on DDL):
- Index Scan using idx_attribution_events_tenant_occurred_at
- Filter on tenant_id and occurred_at
- RLS policy enforcement (tenant_isolation_policy)

**Acceptance Criteria Assessment**:
- ⚠️ DEFERRED: EXPLAIN ANALYZE requires live database with data
- ✅ PASS: Index structure is correct (tenant_id, occurred_at DESC)

### Alex Questions D1-D6 (Consolidated Responses)

#### D1: Primary Index Validation
✅ **PASS** - All 5 tables have UUID primary keys with automatic indexes.

#### D2: Composite Index on Events Table
⚠️ **PARTIAL** - `idx_attribution_events_tenant_occurred_at` exists (equivalent to `idx_events_tenant_timestamp`).

#### D3: Partial Index for Background Workers
❌ **FAILED** - No partial index on `processing_status` (column doesn't exist).

#### D4: Allocations Composite Index for Reporting
❌ **FAILED** - No covering index with INCLUDE clause. Separate indexes exist but not optimal.

#### D5: Query Plan Validation
⚠️ **DEFERRED** - Requires live database with data. DDL analysis suggests indexes will be used correctly.

#### D6: Idempotency Key Index Verification
✅ **PASS** - Unique partial indexes on (tenant_id, external_event_id) and (tenant_id, correlation_id) provide idempotency.

### Category D Summary

**Verdict**: ⚠️ **PARTIALLY IMPLEMENTED** - Basic indexes exist but not all Backend Guide-specified indexes present.

**Indexes Created**: 18 total indexes across all tables ✅  
**Critical Missing**: `processing_status` partial index, covering indexes with INCLUDE ❌  
**Performance Impact**: Moderate - queries will work but may not meet p95 < 50ms targets

**Recommendation**: Add covering indexes for dashboard queries. However, without `processing_status` column, background worker indexes cannot be created.

---

## CATEGORY E: PRIVACY ARCHITECTURE COMPLIANCE

### Billy Question E-01: PII Column Audit

**Question Restated**: Please provide the full DDL for `attribution_events` and `revenue_ledger` for a forensic audit to verify the *absence* of PII-related columns.

**Answer**: ✅ **PASS** - NO PII columns detected.

**attribution_events Columns**:
1. id (uuid)
2. tenant_id (uuid)
3. created_at (timestamptz)
4. updated_at (timestamptz)
5. occurred_at (timestamptz)
6. external_event_id (text) - Could contain PII if not sanitized at ingestion
7. correlation_id (uuid)
8. session_id (uuid)
9. revenue_cents (integer)
10. raw_payload (jsonb) - RISK: Could contain PII if not stripped

**revenue_ledger Columns**:
1. id (uuid)
2. tenant_id (uuid)
3. created_at (timestamptz)
4. updated_at (timestamptz)
5. revenue_cents (integer)
6. is_verified (boolean)
7. verified_at (timestamptz)
8. reconciliation_run_id (uuid)
9. allocation_id (uuid)
10. posted_at (timestamptz)

**Acceptance Criteria Assessment**:
- ✅ PASS: No explicit PII columns (email, name, address, IP, device_id, etc.)
- ⚠️ RISK: `raw_payload` (jsonb) could store PII if B0.4 ingestion doesn't strip it
- ⚠️ RISK: `external_event_id` (text) could encode PII if vendor provides it

**Architectural Impact**: ✅ **GOOD** - Schema is structurally PII-free. Application-layer PII stripping (B0.4) is critical.

### Billy Question E-02: Session-Scoped Design Verification

**Question Restated**: Please confirm that there are no columns that would allow linking multiple `session_id` values to a single user.

**Answer**: ✅ **CONFIRMED** - Session-scoped design is enforced.

**Identifiers Present**:
- `tenant_id` ✅ (isolates data per customer organization)
- `session_id` ✅ (isolates attribution per user session)
- `correlation_id` ✅ (links events within single request, not across sessions)
- `external_event_id` ✅ (vendor event ID, not user ID)

**No Cross-Session Tracking Columns**:
- ❌ NO `user_id`
- ❌ NO `device_id`
- ❌ NO `cookie_id`
- ❌ NO `browser_fingerprint`
- ❌ NO `persistent_id`
- ❌ NO `customer_id`

**Acceptance Criteria Assessment**:
- ✅ PASS: Only `tenant_id` and `session_id` as identifiers
- ✅ PASS: No persistent user identifiers across sessions

**Architectural Impact**: ✅ **EXCELLENT** - Privacy-first architecture fully enforced at schema level.

### Billy Question E-03: Raw Payload PII Prevention

**Question Restated**: What database-level mechanisms (e.g., `CHECK` constraints, triggers) are in place to prevent PII from being stored within the `raw_payload` JSONB field?

**Answer**: ❌ **NO DATABASE-LEVEL ENFORCEMENT** - PII stripping is deferred to application layer (B0.4).

**Evidence**: Comprehensive review of all migrations found NO:
- CHECK constraints on `raw_payload` content
- Triggers to validate or scrub JSONB keys
- Constraint to reject PII-like patterns

**Acceptance Criteria Assessment**:
- ❌ FAILED: No DB-level PII constraint on `raw_payload`
- ⚠️ RISK ACCEPTED: PII enforcement entirely depends on B0.4 application layer

**Architectural Impact**: ⚠️ **MODERATE RISK** - A bug in B0.4 ingestion WILL lead to PII storage. This is a known architectural risk that should be documented.

**Recommendation**: Add trigger-based PII detection (even if non-blocking, logging only) for defense-in-depth.

### Alex Questions E1-E3 (Consolidated)

#### E1: PII Column Audit (SQL Query)
✅ **PASS** - Covered in Billy E-01.

#### E2: Session-Scoped Design Verification
✅ **PASS** - Covered in Billy E-02.

#### E3: Session Expiry Design Validation
✅ **PASS** - `occurred_at` (timestamptz) supports session expiry calculations. No persistent session state columns.

### Category E Summary

**Verdict**: ✅ **MOSTLY COMPLIANT** - Schema enforces privacy-first design with one known risk.

**PII Columns**: None detected ✅  
**Session-Scoped**: Fully enforced ✅  
**PII in JSONB**: No DB-level protection ⚠️ (Application-layer responsibility)

**Recommendation**: Schema is privacy-compliant. Add application-layer PII stripping validation and monitoring.

---

## CATEGORY F: IDEMPOTENCY & DATA QUALITY

### Billy Question F-01: Idempotency Key Structure

**Question Restated**: Can you provide the DDL fragment that implements the `UNIQUE NOT NULL` constraint on the `idempotency_key` column in the `attribution_events` table?

**Answer**: ❌ **COLUMN DOES NOT EXIST** - `idempotency_key` is not present.

**Alternative Mechanism**:
```sql
CREATE UNIQUE INDEX idx_attribution_events_tenant_external_event_id 
    ON attribution_events (tenant_id, external_event_id) 
    WHERE external_event_id IS NOT NULL;

CREATE UNIQUE INDEX idx_attribution_events_tenant_correlation_id 
    ON attribution_events (tenant_id, correlation_id) 
    WHERE correlation_id IS NOT NULL AND external_event_id IS NULL;
```

**Source**: Migration 202511131115, lines 121-131

**FINDING**: ✅ Dual idempotency mechanism using partial unique indexes:
1. Primary: (tenant_id, external_event_id) for vendor-provided event IDs
2. Fallback: (tenant_id, correlation_id) for internal correlation

**Architectural Impact**: ⚠️ **DIFFERENT DESIGN** - Idempotency is enforced but through composite keys, not single column. This is architecturally valid but incompatible with Backend Guide expectations.

### Billy Question F-02: Revenue Ledger Idempotency

**Question Restated**: Can you provide the DDL fragment that implements the `UNIQUE NOT NULL` constraint on the `transaction_id` column in the `revenue_ledger` table?

**Answer**: ❌ **COLUMN DOES NOT EXIST** - `transaction_id` is not present.

**Alternative Mechanism**:
```sql
CREATE UNIQUE INDEX idx_revenue_ledger_tenant_allocation_id
    ON revenue_ledger (tenant_id, allocation_id)
    WHERE allocation_id IS NOT NULL;
```

**Source**: Migration 202511131250, lines 68-72

**FINDING**: ✅ Idempotency enforced via (tenant_id, allocation_id) instead of transaction_id. This prevents duplicate ledger entries per allocation.

**Architectural Impact**: **CRITICAL** - Revenue ledger uses allocation-based idempotency instead of transaction-based. B2.2 (Webhook Ingestion) expecting `transaction_id` will not find it.

### Billy Question F-03: Channel Taxonomy Enforcement

**Question Restated**: Is there any database-level enforcement (e.g., ENUM type, FK to a `channels` table, or CHECK constraint) to ensure only normalized channel names are stored?

**Answer**: ✅ **FULLY ENFORCED** - FK constraint to `channel_taxonomy` table.

```sql
-- channel_taxonomy table created
CREATE TABLE channel_taxonomy (
    code          text PRIMARY KEY,
    family        text NOT NULL,
    is_paid       boolean NOT NULL,
    display_name  text NOT NULL,
    is_active     boolean NOT NULL DEFAULT true,
    created_at    timestamptz NOT NULL DEFAULT now()
);

-- FK constraint added to attribution_allocations
ALTER TABLE attribution_allocations
    ADD CONSTRAINT fk_attribution_allocations_channel_code
    FOREIGN KEY (channel_code) REFERENCES channel_taxonomy(code);
```

**Source**: Migrations 202511141310, 202511141311

**Seeded Canonical Codes**:
- facebook_paid
- facebook_brand
- google_search_paid
- google_display_paid
- tiktok_paid
- direct
- organic
- referral
- email

**Acceptance Criteria Assessment**:
- ✅ PASS: FK constraint enforces taxonomy
- ✅ PASS: Canonical codes seeded from `channel_mapping.yaml`
- ✅ PASS: Legacy values mapped to canonical codes via data backfill

**Architectural Impact**: ✅ **EXCELLENT** - Channel taxonomy is fully enforced at DB level. B0.4 ingestion must map vendor channels to canonical codes or FK constraint will fail.

### Alex Questions F1-F3 (Consolidated)

#### F1: Idempotency Key Structure Validation
❌ **FAILED** - `idempotency_key` doesn't exist; dual partial unique indexes used instead.

#### F2: Channel Taxonomy Column Readiness
✅ **PASS** - `channel_code` (text) with FK to `channel_taxonomy`.

#### F3: JSONB Raw Payload Storage
✅ **PASS** - `raw_payload` is `jsonb NOT NULL` in both `attribution_events` and `dead_events`.

### Category F Summary

**Verdict**: ⚠️ **PARTIALLY COMPLIANT** - Idempotency and taxonomy enforced, but through different mechanisms than specified.

**Idempotency**: Enforced via composite partial unique indexes ⚠️  
**Channel Taxonomy**: Fully enforced via FK ✅  
**JSONB Storage**: Correctly implemented ✅

**Recommendation**: Idempotency works but API contracts expecting `idempotency_key` and `transaction_id` will need adaptation.

---

## CATEGORY G: MIGRATION INFRASTRUCTURE

### Billy Question G-01: Alembic Migration Framework Validation

**Question Restated**: Can you provide the output of `alembic history --verbose`?

**Answer**: ✅ **CONFIRMED** - Alembic is fully configured.

**Evidence**:
1. `alembic.ini` file exists with proper configuration
2. `alembic/env.py` exists with DATABASE_URL environment variable integration
3. `alembic/versions/` directory contains 14 sequential migrations
4. All migrations have proper upgrade() and downgrade() functions

**Migration History** (chronological):
1. baseline (202511121302) - Initial baseline
2. 202511131115 - Add core tables
3. 202511131119 - Add materialized views
4. 202511131120 - Add RLS policies
5. 202511131121 - Add grants
6. 202511131232 - Enhance allocation schema
7. 202511131240 - Add sum-equality validation
8. 202511131250 - Enhance revenue ledger
9. 202511141200 - Revoke events UPDATE/DELETE
10. 202511141201 - Add events guard trigger
11. 202511141300 - Revoke ledger UPDATE/DELETE
12. 202511141301 - Add ledger guard trigger
13. 202511141302 - Ledger allocation_id NOT NULL
14. 202511141310 - Create channel taxonomy
15. 202511141311 - Allocations channel FK to taxonomy

**Acceptance Criteria Assessment**:
- ✅ PASS: Alembic directory structure exists
- ✅ PASS: alembic.ini configured (DATABASE_URL from environment)
- ✅ PASS: 14 migration files exist
- ⚠️ DEFERRED: `alembic current` output requires live database

**Architectural Impact**: ✅ **EXCELLENT** - Migration infrastructure is production-ready.

### Billy Question G-02: Migration Validation Script

**Question Restated**: Can you provide the `scripts/validate-migration.sh` script?

**Answer**: ❌ **SCRIPT DOES NOT EXIST**

**Evidence**: `scripts/` directory contains validation scripts for phases 0-3, but NO `validate-migration.sh`.

**What EXISTS**:
- validate-phase-0.sh
- validate-phase-1.sh
- validate-phase-2.sh
- validate-phase-3.sh

**Acceptance Criteria Assessment**:
- ❌ FAILED: `validate-migration.sh` script does not exist
- ⚠️ GAP: No CI/CD gate to prevent destructive migrations

**Architectural Impact**: **MODERATE RISK** - Without automated destructive change detection, a developer could accidentally commit DROP TABLE/DROP COLUMN migrations.

**Recommendation**: Create `scripts/validate-migration.sh` to grep for destructive DDL patterns (DROP, TRUNCATE, etc.) and integrate into CI/CD.

### Alex Questions G1-G2 (Consolidated)

#### G1: Alembic Migration Framework Validation
✅ **PASS** - Covered in Billy G-01.

#### G2: Migration Rollback Testing
✅ **PASS** - All 14 migrations have downgrade() functions. Rollback logic is present but not tested.

**Sample Downgrade Function**:
```python
def downgrade() -> None:
    op.execute("DROP TABLE IF EXISTS reconciliation_runs CASCADE")
    op.execute("DROP TABLE IF EXISTS revenue_ledger CASCADE")
    op.execute("DROP TABLE IF EXISTS attribution_allocations CASCADE")
    op.execute("DROP TABLE IF EXISTS dead_events CASCADE")
    op.execute("DROP TABLE IF EXISTS attribution_events CASCADE")
    op.execute("DROP TABLE IF EXISTS tenants CASCADE")
```

**Source**: Migration 202511131115, lines 311-331

**Architectural Impact**: ✅ **GOOD** - Rollback procedures documented in code. Testing requires live database.

### Category G Summary

**Verdict**: ⚠️ **MOSTLY COMPLIANT** - Alembic framework is excellent; validation script is missing.

**Alembic Setup**: Fully configured ✅  
**Migrations**: 14 migrations with up/down functions ✅  
**Validation Script**: Missing ❌

**Recommendation**: Create `validate-migration.sh` for CI/CD integration.

---

## CATEGORY H: EXIT GATE CRITERIA MAPPING

### Billy Question H-01: Exit Gate to Migration File Mapping

**Question Restated**: Provide a concise mapping of B0.3 Exit Gate Criteria to specific Alembic migration files.

**Answer**: ✅ **DOCUMENTED MAPPING**

| Exit Gate Criterion | Implementation | Migration File | Status |
|---|---|---|---|
| Core 5 tables created | 6 tables (5 + reconciliation_runs) | 202511131115_add_core_tables.py | ✅ COMPLETE |
| Materialized views for dashboards | 3 MVs (realtime_revenue, reconciliation_status, allocation_summary) | 202511131119_add_materialized_views.py, 202511131240_add_sum_equality_validation.py | ⚠️ NAMES DIFFER |
| RLS policies operational | 5 tables with tenant_isolation_policy | 202511131120_add_rls_policies.py | ✅ COMPLETE |
| Idempotency constraints enforced | Partial unique indexes on composite keys | 202511131115_add_core_tables.py | ⚠️ DIFFERENT MECHANISM |
| Channel taxonomy enforced | FK to channel_taxonomy table | 202511141310_create_channel_taxonomy.py, 202511141311_allocations_channel_fk_to_taxonomy.py | ✅ COMPLETE |
| Events immutability enforced | Privilege revocation + guard trigger | 202511141200_revoke_events_update_delete.py, 202511141201_add_events_guard_trigger.py | ✅ COMPLETE |
| Ledger immutability enforced | Privilege revocation + guard trigger | 202511141300_revoke_ledger_update_delete.py, 202511141301_add_ledger_guard_trigger.py | ✅ COMPLETE |
| Performance indexes created | 18 indexes across tables | 202511131115_add_core_tables.py, others | ⚠️ PARTIAL |
| Migration framework configured | Alembic with 14 migrations | alembic.ini, alembic/env.py | ✅ COMPLETE |

**Acceptance Criteria Assessment**:
- ✅ PASS: All major exit gates have corresponding migrations
- ⚠️ PARTIAL: Some implementations differ from Backend Guide specifications

**Architectural Impact**: ✅ **MOSTLY COMPLETE** - Exit gates are met with design deviations noted.

---

## CATEGORY I: B0.4 DEPENDENCY READINESS

### Billy Question I-01: Schema Match for attribution_events and dead_events

**Question Restated**: Can you confirm the DDL for `attribution_events` and `dead_events` *exactly* matches the schema defined in `001_initial_schema.py`?

**Answer**: ❌ **SCHEMA MISMATCH** - Implemented schema fundamentally differs from Backend Guide § 3.1.

**Critical Differences for B0.4 Ingestion**:
1. NO `event_type` column (BLOCKING)
2. NO `channel` column (BLOCKING)
3. NO `campaign_id` column (HIGH impact)
4. NO `processing_status` column (BLOCKING for background workers)
5. Uses `external_event_id` + `correlation_id` instead of `idempotency_key`

**Architectural Impact**: **BLOCKING** - B0.4 ingestion service code written to Backend Guide specifications will fail on INSERT due to missing columns.

**Recommendation**: Either:
1. Update Backend Guide to match implemented schema, OR
2. Add missing columns via new migration before starting B0.4

### Billy Question I-02: dead_events Index for Remediation

**Question Restated**: Can you provide the DDL for `idx_dead_events_remediation`?

**Answer**: ❌ **INDEX DOES NOT EXIST** - The column `remediation_status` does not exist.

**Similar Indexes That DO Exist**:
- `idx_dead_events_tenant_ingested_at` (tenant_id, ingested_at DESC)
- `idx_dead_events_source` (source)
- `idx_dead_events_error_code` (error_code)

**Expected (from Backend Guide)**:
```sql
CREATE INDEX idx_dead_events_remediation 
    ON dead_events (remediation_status, created_at DESC);
```

**Architectural Impact**: **MODERATE** - B0.5 (Background Workers) remediation worker will need to query by `error_code` or `source` instead of `remediation_status`.

### Category I Summary

**Verdict**: ❌ **NOT READY** - Schema diverges significantly from Backend Guide, blocking B0.4.

**Schema Match**: Multiple critical columns missing ❌  
**Remediation Index**: Does not exist ❌

**Recommendation**: **BLOCKING** - Reconcile schema differences before proceeding to B0.4.

---

## FINAL RECOMMENDATIONS

### Critical Path Items (BLOCKING B0.4)
1. **Resolve Schema Divergence**: Determine if Backend Guide or implementation is authoritative
2. **Add Missing Columns**: If Backend Guide is correct, add `event_type`, `channel`, `processing_status`, `transaction_id`, etc.
3. **Update API Contracts**: If implementation is correct, update all documentation and API contracts

### High Priority Items
1. **Create `validate-migration.sh` Script**: Prevent destructive migrations in CI/CD
2. **Add PII Detection Trigger**: Defense-in-depth for raw_payload JSONB
3. **Document Design Decisions**: Explain why allocation-based design was chosen over transaction-based

### Medium Priority Items
1. **Add Covering Indexes**: Optimize dashboard query performance with INCLUDE clauses
2. **Backfill Missing NOT NULL**: Make `session_id` NOT NULL for privacy enforcement
3. **Create Missing Materialized Views**: Add `mv_channel_performance` if needed by B2.6

### Positive Findings
1. **Excellent Tenant Isolation**: RLS policies are comprehensive and use FORCE for defense-in-depth ✅
2. **Strong Immutability**: Dual-layer enforcement (privileges + triggers) for events and ledger ✅
3. **Good Channel Taxonomy**: FK-enforced canonical channel codes with data backfill ✅
4. **Solid Migration Infrastructure**: Alembic properly configured with 14 versioned migrations ✅

---

## CONCLUSION

**Overall B0.3 Assessment**: ⚠️ **PHASE COMPLETE WITH DEVIATIONS**

The B0.3 database schema foundation is **functionally complete** but **architecturally divergent** from Backend Guide specifications. This represents a **design fork** that must be reconciled before proceeding to B0.4.

**Strengths**:
- Tenant isolation (Category C): **EXEMPLARY** ✅
- Immutability enforcement: **EXCELLENT** ✅
- Migration infrastructure: **PRODUCTION-READY** ✅

**Weaknesses**:
- Schema divergence (Category A): **SIGNIFICANT** ❌
- Missing columns for B0.4: **BLOCKING** ❌
- Documentation mismatch: **HIGH IMPACT** ⚠️

**Decision Required**: Stakeholders must determine whether to:
1. **Update Backend Guide** to document the implemented schema as the new standard, OR
2. **Modify Schema** via new migrations to match Backend Guide specifications

Until this decision is made, **B0.4 development should not proceed** as API contracts are ambiguous.

---

**END OF FORENSIC ANALYSIS**

