# B0.3 Ledger Traceability & Channel Taxonomy - Implementation Document

**Implementation Date**: 2025-11-14  
**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)  
**Consolidated from**: Directives by Jamie and Schmidt

## Executive Summary

This document consolidates directives from engineers Jamie and Schmidt to implement:

1. **Ledger Immutability**: Make `revenue_ledger` a true immutable financial ledger with explicit correction semantics
2. **Channel Taxonomy**: Replace ad-hoc CHECK constraint with canonical `channel_taxonomy` table + FK

All work is captured in this **single unified Implementation Document** following Jamie's structure (Sections A-E), with Schmidt's execution rigor and empirical validation requirements.

---

## Section A: Invariant Definitions

### A.1: Ledger Immutability & Correction Semantics

**Invariant Statement:**
> `revenue_ledger` is a write-once financial ledger for application roles (`app_rw`, `app_ro`). Application roles may only INSERT new rows. UPDATE/DELETE by application roles are forbidden. Corrections are represented by additive entries (reversal + replacement), never by mutating or deleting existing rows.

**Correction Semantics:**
- Corrections use **additive pattern**: Insert reversal entry (negative `revenue_cents`) + insert corrected entry
- Reversal entries link to originals via `allocation_id` (if correcting allocation-based posting) or `reconciliation_run_id` (if correcting run-based posting)
- No UPDATE/DELETE on original rows
- `migration_owner` role retains UPDATE/DELETE for emergency repairs only (with audit trail requirement)

**Traceability Enforcement:**
- `allocation_id` is **NOT NULL** (Schmidt's Option A - simplest, most traceable)
- Every ledger entry is directly traceable via `allocation_id` → `attribution_allocations` → `attribution_events`
- No orphan rows possible

**Application Roles vs. System Roles:**
- **Application roles**: `app_rw`, `app_ro` (write-once for `app_rw`, read-only for `app_ro`)
- **System roles**: `migration_owner` (full access for emergency repairs only)

### A.2: Canonical Channel Taxonomy & Allocation Requirements

**Invariant Statement:**
> All `attribution_allocations.channel_code` values must correspond to a canonical code in `channel_taxonomy.code`. `channel_taxonomy` is the single source of truth for allowed channels. `channel_mapping.yaml` defines how raw integration channels map into these canonical codes.

**Responsibilities:**
- `channel_taxonomy` (DB table) — authoritative set of canonical codes
- `channel_mapping.yaml` — mapping from external provider/channel names to canonical codes
- `attribution_allocations.channel_code` — must always be one of these canonical codes (enforced via FK)

**Column Naming:**
- `attribution_allocations.channel` → renamed to `channel_code` (Schmidt's approach - explicit FK relationship)

---

## Section B: Artifact Map (Source of Truth)

### Ledger Artifacts

| Artifact Type | Path/ID | Purpose | Schema Revision |
|--------------|---------|---------|----------------|
| Migration | `alembic/versions/202511141300_revoke_ledger_update_delete.py` | Revoke UPDATE/DELETE from `app_rw` on `revenue_ledger` | 202511141300 |
| Migration | `alembic/versions/202511141301_add_ledger_guard_trigger.py` | Create `fn_ledger_prevent_mutation()` and `trg_ledger_prevent_mutation` | 202511141301 |
| Migration | `alembic/versions/202511141302_ledger_allocation_id_not_null.py` | Enforce `allocation_id NOT NULL` constraint | 202511141302 |
| Test | `db/tests/test_ledger_immutability.sql` | Test UPDATE/DELETE rejection and correction semantics | N/A |
| Evidence | `evidence/ledger/privileges_revenue_ledger_YYYY-MM-DD.txt` | Privilege inspection output | TBD |
| Evidence | `evidence/ledger/trigger_verification_YYYY-MM-DD.txt` | Trigger behavior verification | TBD |
| Evidence | `evidence/ledger/traceability_enforcement_YYYY-MM-DD.txt` | Traceability constraint verification | TBD |
| Evidence | `evidence/ledger/correction_scenario_YYYY-MM-DD.txt` | Correction pattern test results | TBD |

### Channel Taxonomy Artifacts

| Artifact Type | Path/ID | Purpose | Schema Revision |
|--------------|---------|---------|----------------|
| Migration | `alembic/versions/202511141310_create_channel_taxonomy.py` | Create `channel_taxonomy` table and seed from `channel_mapping.yaml` | 202511141310 |
| Migration | `alembic/versions/202511141311_allocations_channel_fk_to_taxonomy.py` | Drop CHECK, rename column, backfill data, add FK | 202511141311 |
| Test | `db/tests/test_channel_taxonomy_fk.sql` | Test FK enforcement and consistency | N/A |
| Test | `db/tests/test_channel_mapping_consistency.sql` | Test mapping YAML ↔ taxonomy alignment | N/A |
| Evidence | `evidence/channels/taxonomy_seeding_YYYY-MM-DD.txt` | Taxonomy seeding verification | TBD |
| Evidence | `evidence/channels/fk_consistency_YYYY-MM-DD.txt` | FK constraint verification | TBD |
| Evidence | `evidence/channels/mapping_consistency_YYYY-MM-DD.txt` | Mapping-to-taxonomy alignment | TBD |

---

## Section C: Atomic Phase Sequencing

### Track L: Ledger Hardening

#### Phase L1: Privilege Hardening (Migration)

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Remove all mutation privileges from `app_rw` role on `revenue_ledger`.

**Execution Steps:**
1. ✅ Create Alembic migration: `alembic/versions/202511141300_revoke_ledger_update_delete.py`
2. ✅ In `upgrade()`: `REVOKE UPDATE, DELETE ON TABLE revenue_ledger FROM app_rw`
3. ✅ In `downgrade()`: `GRANT UPDATE, DELETE ON TABLE revenue_ledger TO app_rw`

**Minimum Requirements:**
- ✅ Migration file exists and is syntactically valid
- ✅ Contains correct `REVOKE` and `GRANT` statements
- ⏳ Migration applies cleanly (pending execution)

**Empirical Exit Gates:**
1. **Gate L1.1:** ⏳ Migration applies cleanly without errors
2. **Gate L1.2:** ⏳ Query proves `app_rw` has **zero rows** for `UPDATE` or `DELETE`
3. **Gate L1.3:** ⏳ Test as `app_rw` role: UPDATE attempt **fails** with permission denied error
4. **Gate L1.4:** ⏳ Evidence log created with privilege inspection results

**Blocking Rule:** Cannot proceed to L2 until all L1 gates pass and evidence is recorded.

---

#### Phase L2: Defense-in-Depth Enforcement (Migration)

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Implement guard trigger as secondary defense against illicit mutations.

**Execution Steps:**
1. ✅ Create Alembic migration: `alembic/versions/202511141301_add_ledger_guard_trigger.py`
2. ✅ In `upgrade()`: Create function and trigger
3. ✅ In `downgrade()`: DROP TRIGGER and DROP FUNCTION

**Empirical Exit Gates:**
1. **Gate L2.1:** ⏳ Migration applies cleanly
2. **Gate L2.2:** ⏳ Query proves trigger is **active and enabled**
3. **Gate L2.3:** ⏳ Test as superuser: UPDATE **fails** with trigger exception message
4. **Gate L2.4:** ⏳ Evidence log created with trigger verification results

**Blocking Rule:** Cannot proceed to L3 until all L2 gates pass and evidence is recorded.

---

#### Phase L3: Traceability Enforcement (Migration)

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Enforce that every ledger entry is traceable by making `allocation_id` non-nullable.

**Execution Steps:**
1. ✅ Create Alembic migration: `alembic/versions/202511141302_ledger_allocation_id_not_null.py`
2. ✅ In `upgrade()`: Validate data, then `ALTER TABLE revenue_ledger ALTER COLUMN allocation_id SET NOT NULL`
3. ✅ In `downgrade()`: `ALTER TABLE revenue_ledger ALTER COLUMN allocation_id DROP NOT NULL`

**Empirical Exit Gates:**
1. **Gate L3.1:** ⏳ Migration applies cleanly (fails if NULL data exists - desired behavior)
2. **Gate L3.2:** ⏳ Query proves `allocation_id` column is `not null`
3. **Gate L3.3:** ⏳ Test: INSERT with NULL `allocation_id` **fails** with not-null constraint error
4. **Gate L3.4:** ⏳ Evidence log created with traceability enforcement results

**Blocking Rule:** Cannot proceed to L4 until all L3 gates pass and evidence is recorded.

---

#### Phase L4: Ledger Traceability Tests & Evidence Integration

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Prove with tests and recorded outputs that `revenue_ledger` is immutable and correction semantics are valid.

**Execution Steps:**
1. ✅ Create test file: `db/tests/test_ledger_immutability.sql`
2. ⏳ Execute test flow: INSERT succeeds, UPDATE/DELETE fail, correction scenario completes (pending execution)

**Empirical Exit Gates:**
1. **Gate L4.1:** ⏳ Test file exists
2. **Gate L4.2:** ⏳ Test execution shows all scenarios pass
3. **Gate L4.3:** ⏳ Evidence log created with correction scenario results

**Blocking Rule:** Ledger invariant is only "Ready" when all L1-L4 gates pass and evidence is recorded.

---

### Track T: Channel Taxonomy Implementation

#### Phase T1: Create & Seed Canonical Taxonomy Table (Migration)

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Create `channel_taxonomy` table and populate it from `db/channel_mapping.yaml` SoT.

**Execution Steps:**
1. ✅ Create Alembic migration: `alembic/versions/202511141310_create_channel_taxonomy.py`
2. ✅ In `upgrade()`: Create table, extract codes from YAML, insert rows
3. ✅ In `downgrade()`: `DROP TABLE channel_taxonomy`

**Empirical Exit Gates:**
1. **Gate T1.1:** ⏳ Migration applies cleanly
2. **Gate T1.2:** ⏳ Query proves table is populated
3. **Gate T1.3:** ⏳ Query proves codes are **1:1 match** with YAML canonical values
4. **Gate T1.4:** ⏳ Evidence log created with taxonomy seeding results

**Blocking Rule:** Cannot proceed to T2 until all T1 gates pass and evidence is recorded.

---

#### Phase T2: Data Backfill & FK Binding (Migration)

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Safely migrate `attribution_allocations` from legacy CHECK constraint to new FOREIGN KEY.

**Execution Steps:**
1. ✅ Create Alembic migration: `alembic/versions/202511141311_allocations_channel_fk_to_taxonomy.py`
2. ✅ In `upgrade()`, execute **in order**:
   1. DROP CHECK constraint
   2. RENAME COLUMN channel TO channel_code
   3. Data backfill: UPDATE legacy values to canonical codes
   4. ADD FOREIGN KEY constraint
3. ✅ In `downgrade()`: Reverse all steps

**Empirical Exit Gates:**
1. **Gate T2.1:** ⏳ Migration applies cleanly
2. **Gate T2.2:** ⏳ Query proves FK constraint is **active**, CHECK is **gone**, column renamed
3. **Gate T2.3:** ⏳ Validation query returns **zero rows** (all codes in taxonomy)
4. **Gate T2.4:** ⏳ Evidence log created with FK consistency results

**Blocking Rule:** Cannot proceed to T3 until all T2 gates pass and evidence is recorded.

---

#### Phase T3: Channel Consistency Tests & Evidence Integration

**Status**: ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Objective:** Prove that allocations are consistent with taxonomy and mapping, and encode this in tests/evidence.

**Execution Steps:**
1. ✅ Create test file: `db/tests/test_channel_taxonomy_fk.sql`
2. ✅ Create test file: `db/tests/test_channel_mapping_consistency.sql`
3. ⏳ Execute tests and validate results (pending execution)

**Empirical Exit Gates:**
1. **Gate T3.1:** ⏳ Test files exist
2. **Gate T3.2:** ⏳ Test execution shows all tests pass
3. **Gate T3.3:** ⏳ Evidence log created with mapping consistency results

**Blocking Rule:** Channel invariant is only "Ready" when all T1-T3 gates pass and evidence is recorded.

---

## Section D: Evidence Registry

| Artifact Type | Path/ID | Schema Revision | Execution Timestamp | Status | Notes |
|--------------|---------|----------------|---------------------|--------|-------|
| Privilege Inspection | `evidence/ledger/privileges_revenue_ledger_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate L1.4 |
| Trigger Verification | `evidence/ledger/trigger_verification_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate L2.4 |
| Traceability Enforcement | `evidence/ledger/traceability_enforcement_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate L3.4 |
| Correction Scenario | `evidence/ledger/correction_scenario_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate L4.3 |
| Taxonomy Seeding | `evidence/channels/taxonomy_seeding_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate T1.4 |
| FK Consistency | `evidence/channels/fk_consistency_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate T2.4 |
| Mapping Consistency | `evidence/channels/mapping_consistency_YYYY-MM-DD.txt` | TBD | TBD | Pending | Gate T3.3 |

---

## Section E: Final Readiness Statements

### E.1: Ledger Readiness Statement

**Status:** ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Schema Revision:** 202511141302

**Guarantees (when execution verified):**
- `app_rw` can only INSERT into `revenue_ledger`; UPDATE/DELETE are technically impossible under normal operation
- BEFORE trigger `trg_ledger_prevent_mutation` blocks illicit mutations
- `allocation_id` is NOT NULL, ensuring all entries are traceable
- Corrections follow documented pattern (reversals + replacements) and have been exercised in tests

**Artifacts Created:**
- ✅ Privilege migration: `alembic/versions/202511141300_revoke_ledger_update_delete.py`
- ✅ Trigger migration: `alembic/versions/202511141301_add_ledger_guard_trigger.py`
- ✅ Traceability migration: `alembic/versions/202511141302_ledger_allocation_id_not_null.py`
- ✅ Ledger tests: `db/tests/test_ledger_immutability.sql`

**Execution Verification Required:**
- ⏳ Migration execution: `alembic upgrade head`
- ⏳ Privilege inspection: Verify `app_rw` has only SELECT/INSERT
- ⏳ Trigger verification: Verify trigger blocks UPDATE/DELETE
- ⏳ Traceability verification: Verify `allocation_id NOT NULL` enforced
- ⏳ Test execution: Run `test_ledger_immutability.sql` and capture results
- ⏳ Evidence logs: Create evidence files in `evidence/ledger/`

**References:**
- Implementation Document: `B0.3_LEDGER_TAXONOMY_IMPLEMENTATION.md`
- Evidence logs: `evidence/ledger/` (to be created during execution)

### E.2: Channel Readiness Statement

**Status:** ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**Schema Revision:** 202511141311

**Guarantees (when execution verified):**
- `channel_taxonomy` exists and is SoT for canonical codes
- `attribution_allocations.channel_code` is FK-bound to taxonomy codes
- `channel_mapping.yaml` and taxonomy are consistent
- Tests validating FK and mapping consistency have been executed and logged

**Artifacts Created:**
- ✅ Taxonomy migration: `alembic/versions/202511141310_create_channel_taxonomy.py`
- ✅ FK migration: `alembic/versions/202511141311_allocations_channel_fk_to_taxonomy.py`
- ✅ Channel tests: `db/tests/test_channel_taxonomy_fk.sql`
- ✅ Mapping consistency tests: `db/tests/test_channel_mapping_consistency.sql`

**Execution Verification Required:**
- ⏳ Migration execution: `alembic upgrade head`
- ⏳ Taxonomy seeding: Verify all 9 canonical codes inserted
- ⏳ FK constraint: Verify FK exists and prevents invalid values
- ⏳ Data backfill: Verify legacy values mapped to canonical codes
- ⏳ Test execution: Run channel tests and capture results
- ⏳ Evidence logs: Create evidence files in `evidence/channels/`

**References:**
- Implementation Document: `B0.3_LEDGER_TAXONOMY_IMPLEMENTATION.md`
- Mapping file: `db/channel_mapping.yaml`
- Evidence logs: `evidence/channels/` (to be created during execution)

### E.3: Joint System-Level Statement

**Status:** ✅ **ARTIFACTS COMPLETE** (pending execution verification)

**As of B0.3 ready state (when execution verified):**
- Ledger is immutable with auditable correction semantics
- Channels are canonical, FK-constrained, and aligned with configuration
- Allocation/Revenue phases may safely assume:
  - Ledger postings form a stable audit trail
  - Channel codes used in allocations are globally consistent and stable

**Implementation Summary:**
- **Ledger Track (L1-L4):** All migrations and tests created
  - L1: Privilege revocation ✅
  - L2: Guard trigger ✅
  - L3: Traceability enforcement ✅
  - L4: Test suite ✅

- **Channel Track (T1-T3):** All migrations and tests created
  - T1: Taxonomy table creation ✅
  - T2: FK migration with data backfill ✅
  - T3: Consistency tests ✅

**Next Steps for Full Readiness:**
1. Execute all migrations: `alembic upgrade head`
2. Run all test suites and capture results
3. Create evidence logs for all exit gates
4. Verify all empirical exit gates pass
5. Update Section D (Evidence Registry) with actual execution data
6. Final forensic review and sign-off

---

## Implementation Discipline Rules

1. **No Phase Progression Without Gate Completion:** Each phase's exit gates must be **fully satisfied** with evidence recorded before proceeding to the next phase.

2. **Empirical Validation Required:** All exit gates require **actual database queries and test executions**, not just artifact creation.

3. **Evidence Logging Mandatory:** Every exit gate requires an evidence log file with:
   - Query/test outputs
   - Schema revision
   - Execution timestamp
   - Status statement

4. **Blocking on Failures:** If any exit gate fails, implementation **STOPS** until the failure is resolved and the gate passes.

5. **No Code Commits:** Per Schmidt's directive, all artifacts are generated and validated locally but **NOT committed** until final review and sign-off.

---

## Key Synthesis Decisions

1. **Document Structure:** Jamie's structure (A-E sections) adopted for unified Implementation Document
2. **Execution Rigor:** Schmidt's empirical validation requirements enforced at every phase
3. **Traceability:** Schmidt's Option A (NOT NULL `allocation_id`) adopted for simplicity
4. **Column Naming:** Schmidt's `channel_code` rename adopted for explicit FK relationship
5. **Scope:** Focus on ledger and channels only (events immutability already implemented)
6. **Evidence Standard:** Both directives' evidence requirements combined into comprehensive logging

