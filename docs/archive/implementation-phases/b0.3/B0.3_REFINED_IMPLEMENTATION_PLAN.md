# B0.3 Integrated Implementation Plan: Forensic Analysis & Synthesis (Refined)

## Executive Summary

**Current State**: Governance baseline complete (migrations, style guides, templates), but zero database schema implementation exists. B0.1 (contracts) and B0.2 (mocks) are complete.

**Directive Analysis**: Two complementary approaches identified:
- **Jamie (V1)**: Specs/templates-first, static validation, no commits (Phase 1: Tenancy+RLS, Phase 2: Ingestion)
- **Schmidt (V2)**: Implementation-first, empirical testing, migrations (Phase 2: Core Tables, Phase 3: RLS)

**Synthesis Strategy**: Hybrid approach—specs/validation first (Jamie), then immediate implementation (Schmidt), with unified entity naming and comprehensive exit gates.

**Critical Enforcement**: **NO PHASE ADVANCEMENT PERMITTED** until ALL exit gates are empirically validated and documented. Each phase has blocking conditions that prevent progression.

---

## Part I: Forensic Analysis of Directive Versions

### A. Convergence Points (Agreement)

1. **Core Entities Required**:
   - `tenants` (both agree)
   - Events table (Jamie: `events`, Schmidt: `attribution_events` - **RESOLVED**: Use `attribution_events` per `.cursor/rules:168`)
   - Dead-letter queue (Jamie: `dlq`, Schmidt: `dead_events` - **RESOLVED**: Use `dead_events` per `.cursor/rules:152`)
   - Additional entities (Schmidt): `attribution_allocations`, `revenue_ledger`, `reconciliation_runs`

2. **RLS & Tenant Isolation**: Both mandate RLS with `current_setting('app.current_tenant_id')`, FORCE RLS, default-deny policies.

3. **Idempotency**: Both require unique constraints on `(tenant_id, external_event_id)` or `(tenant_id, correlation_id)`.

4. **Governance Compliance**: Both require style guide adherence, contract mapping, lint validation.

### B. Divergence Points (Conflicts Resolved)

1. **Naming Convention**: Use `attribution_events` (matches `.cursor/rules:168` and contract domain)
2. **DLQ Table Name**: Use `dead_events` (matches `.cursor/rules:152`)
3. **Entity Scope**: Implement all 6 entities (Schmidt's scope) - supports all contract endpoints
4. **Implementation Sequence**: Hybrid—specs/validation first, then immediate implementation

### C. Gaps Identified & Resolved

1. **Missing from Jamie**: `reconciliation_runs` table → Include in Phase 2.1
2. **Missing from Schmidt**: Explicit correlation_id semantics → Include in Phase 2.4
3. **Missing from Both**: Materialized views → Add Phase 2.5
4. **Missing from Both**: Explicit index justification → Include in Phase 2.3

---

## Part II: Integrated Phase Sequencing with Rigorous Exit Gates

### Phase 1: Tenancy Foundation Validation (Pre-Implementation Gate)

**Intent**: Empirically verify governance baseline readiness before any DDL implementation.

**Validation Steps** (MANDATORY - blocks Phase 2):
1. **1.1 Tenancy Spine Verification**:
   - [ ] Verify `SCHEMA_STYLE_GUIDE.md` documents `tenant_id uuid NOT NULL` convention
   - [ ] Verify PK convention documented: `id uuid PRIMARY KEY DEFAULT gen_random_uuid()`
   - [ ] Verify timestamp standard documented: `created_at timestamptz NOT NULL DEFAULT now()`
   - **Forensic Check**: Run `grep -r "tenant_id.*uuid.*NOT NULL" db/docs/` → Must find matches
   - **Forensic Check**: Run `grep -r "gen_random_uuid" db/docs/` → Must find matches

2. **1.2 Roles & GRANTs Matrix Verification**:
   - [ ] Verify `ROLES_AND_GRANTS.md` exists and documents `app_rw`, `app_ro`, `app_admin`, `migration_owner`
   - [ ] Verify GRANT template pattern documented
   - **Forensic Check**: Run `grep -r "app_rw\|app_ro\|app_admin" db/docs/ROLES_AND_GRANTS.md` → Must find all 3 roles
   - **Forensic Check**: Verify least-privilege matrix table present in documentation

3. **1.3 RLS Substrate Verification**:
   - [ ] Verify `db/migrations/templates/rls_policy.py.template` exists
   - [ ] Verify template uses `current_setting('app.current_tenant_id')::uuid` pattern
   - [ ] Verify GUC contract documented
   - **Forensic Check**: Run `grep -r "current_setting.*app.current_tenant_id" db/` → Must find matches
   - **Forensic Check**: Verify `FORCE ROW LEVEL SECURITY` pattern in template

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 1.1.1**: Style guide documents all tenancy conventions (verified via grep)
- ✅ **Gate 1.2.1**: Role matrix complete with all 4 roles (verified via grep)
- ✅ **Gate 1.3.1**: RLS template exists and uses correct GUC pattern (verified via file existence + grep)
- ✅ **Gate 1.3.2**: FORCE RLS pattern documented (verified via grep)
- ✅ **Gate 1.4.1**: PR template exists (`.github/PULL_REQUEST_TEMPLATE/schema-migration.md`)

**Blocking Condition**: If ANY exit gate fails, Phase 2 is **PROHIBITED**. Must remediate Phase 1 before proceeding.

**Empirical Proof Required**: 
- File existence checks (verified)
- Pattern matching via grep (verified)
- Documentation completeness (verified)

**Status**: ✅ **COMPLETE** (governance baseline verified empirically)

---

### Phase 2: Core Table Implementation (Implementation Phase)

**Intent**: Implement core tables with contract alignment, idempotency, and DLQ.

#### 2.1 Core Table DDL Specification (BLOCKING PHASE)

**Entities to Implement** (all 6 required):
1. `tenants` (if not exists)
2. `attribution_events`
3. `dead_events`
4. `attribution_allocations`
5. `revenue_ledger`
6. `reconciliation_runs`

**DDL Specification Requirements** (per `CONTRACT_TO_SCHEMA_MAPPING.md`):

**For each table, create DDL spec file** (`db/docs/specs/{table_name}_ddl_spec.sql`):
- Complete CREATE TABLE statement
- All columns with types, nullability, defaults
- All constraints (PK, FK, CHECK, UNIQUE)
- All indexes (with naming per style guide)
- All comments (per comment requirements)

**Contract Alignment Validation** (per `DDL_LINT_RULES.md`):
- **Rule 1**: Every table has `COMMENT ON TABLE` (verified via grep)
- **Rule 2**: No generic column names (`data`, `misc`, `other`, `stuff`) (verified via grep)
- **Rule 3**: Required fields are `NOT NULL` (cross-reference with contract `required` arrays)
- **Rule 4**: All multi-tenant tables have `tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE`
- **Rule 5**: RLS policy tag present (documented in comments)
- **Rule 6**: Revenue columns use `INTEGER` (cents), never `DECIMAL` or `FLOAT` (verified via grep)
- **Rule 7**: Time-series indexes on `(tenant_id, timestamp DESC)` where applicable

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 2.1.1**: DDL spec files exist for all 6 tables (`db/docs/specs/*_ddl_spec.sql`)
- ✅ **Gate 2.1.2**: All tables have `COMMENT ON TABLE` statements (verified via `grep -r "COMMENT ON TABLE" db/docs/specs/` → 6 matches)
- ✅ **Gate 2.1.3**: No generic column names (verified via `grep -E "(data|misc|other|stuff)" db/docs/specs/` → 0 matches)
- ✅ **Gate 2.1.4**: All required contract fields map to `NOT NULL` (manual verification per contract)
- ✅ **Gate 2.1.5**: All multi-tenant tables have `tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE` (verified via `grep -r "tenant_id.*uuid.*NOT NULL.*REFERENCES tenants" db/docs/specs/` → 5 matches for multi-tenant tables)
- ✅ **Gate 2.1.6**: Revenue columns use `INTEGER`, not `DECIMAL` or `FLOAT` (verified via `grep -E "revenue.*(DECIMAL|FLOAT|NUMERIC)" db/docs/specs/` → 0 matches)
- ✅ **Gate 2.1.7**: Time-series indexes present where applicable (verified via `grep -r "idx.*tenant.*timestamp\|idx.*tenant.*created_at\|idx.*tenant.*occurred_at" db/docs/specs/` → matches for time-series tables)
- ✅ **Gate 2.1.8**: Type mappings verified (uuid→uuid, number(float)→integer(cents), boolean→boolean, string(date-time)→timestamptz)
- ✅ **Gate 2.1.9**: Idempotency constraints defined (UNIQUE on `(tenant_id, external_event_id)` or `(tenant_id, correlation_id)`)

**Blocking Condition**: If ANY exit gate fails, Phase 2.2 is **PROHIBITED**. Must remediate DDL specs before creating migrations.

**Empirical Proof Required**:
- File existence (6 spec files)
- Pattern matching via grep (all rules verified)
- Manual contract cross-reference (required fields → NOT NULL)

---

#### 2.2 Alembic Migration Creation (BLOCKING PHASE)

**Steps** (MANDATORY):
1. Create versioned migration: `YYYYMMDDHHMM_add_core_tables.py`
2. Implement `upgrade()`: CREATE TABLE statements for all 6 entities (copy from DDL specs)
3. Implement `downgrade()`: DROP TABLE statements in reverse order (reversible)
4. Apply style guide: snake_case, comments, CHECK constraints
5. Test locally on fresh database:
   - `alembic upgrade head` → Must succeed
   - `alembic downgrade -1` → Must succeed
   - `alembic upgrade head` → Must succeed again (idempotency)

**Migration Validation** (per `MIGRATION_SAFETY_CHECKLIST.md`):
- Lock timeout: `SET lock_timeout = '30s';` (if applicable)
- Statement timeout: `SET statement_timeout = '5min';` (if applicable)
- No hardcoded credentials (use `DATABASE_URL` env var)
- Reversible downgrade function

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 2.2.1**: Migration file exists (`alembic/versions/YYYYMMDDHHMM_add_core_tables.py`)
- ✅ **Gate 2.2.2**: `upgrade()` function creates all 6 tables (verified via `grep -r "CREATE TABLE" alembic/versions/YYYYMMDDHHMM_add_core_tables.py` → 6 matches)
- ✅ **Gate 2.2.3**: `downgrade()` function drops all 6 tables (verified via `grep -r "DROP TABLE" alembic/versions/YYYYMMDDHHMM_add_core_tables.py` → 6 matches)
- ✅ **Gate 2.2.4**: Migration applies cleanly on fresh database (`alembic upgrade head` → success, verified via test execution)
- ✅ **Gate 2.2.5**: Migration reverses without state loss (`alembic downgrade -1` → success, verified via test execution)
- ✅ **Gate 2.2.6**: Migration is idempotent (`alembic upgrade head` after downgrade → success, verified via test execution)
- ✅ **Gate 2.2.7**: All DDL lint rules pass (run lint tool → zero errors)
- ✅ **Gate 2.2.8**: No hardcoded credentials (verified via `grep -r "password\|user.*=" alembic/versions/YYYYMMDDHHMM_add_core_tables.py` → 0 matches)

**Blocking Condition**: If ANY exit gate fails, Phase 2.3 is **PROHIBITED**. Must fix migration before proceeding.

**Empirical Proof Required**:
- File existence
- Pattern matching (CREATE TABLE, DROP TABLE counts)
- Test execution results (upgrade/downgrade/idempotency)
- Lint tool output (zero errors)

---

#### 2.3 Idempotency & Index Plan (BLOCKING PHASE)

**Idempotency Constraints** (MANDATORY):
- `attribution_events`: `UNIQUE (tenant_id, external_event_id)` (when `external_event_id` present)
- `attribution_events`: `UNIQUE (tenant_id, correlation_id)` (fallback when `external_event_id` null)
- Document per-source strategy in `db/docs/IDEMPOTENCY_STRATEGY.md`:
  - Shopify: `external_event_id` (order ID)
  - Stripe: `correlation_id` (payment intent ID)
  - PayPal: `external_event_id` (transaction ID)
  - WooCommerce: `external_event_id` (order ID)

**Index Plan** (justified by access patterns - MANDATORY):
Create `db/docs/INDEX_PLAN.md` with:
- For each index: table name, columns, sort order, query path justification
- Indexes required:
  - `attribution_events`: `(tenant_id, occurred_at DESC)` → Supports `GET /api/attribution/revenue/realtime?tenant_id=X`
  - `dead_events`: `(tenant_id, ingested_at DESC)` → Supports operator triage queries
  - `reconciliation_runs`: `(tenant_id, last_run_at DESC)` → Supports `GET /api/reconciliation/status?tenant_id=X`
- **Defer GIN on JSONB**: Only add if query paths require it (avoid over-engineering)

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 2.3.1**: Idempotency strategy document exists (`db/docs/IDEMPOTENCY_STRATEGY.md`)
- ✅ **Gate 2.3.2**: All 4 webhook sources documented with idempotency key strategy (verified via grep)
- ✅ **Gate 2.3.3**: Index plan document exists (`db/docs/INDEX_PLAN.md`)
- ✅ **Gate 2.3.4**: Each index linked to concrete contract query path (manual verification)
- ✅ **Gate 2.3.5**: No speculative indexes (all indexes justified by query paths)
- ✅ **Gate 2.3.6**: UNIQUE constraints defined in migration (verified via `grep -r "UNIQUE\|CREATE UNIQUE INDEX" alembic/versions/YYYYMMDDHHMM_add_core_tables.py` → matches for idempotency)

**Blocking Condition**: If ANY exit gate fails, Phase 2.4 is **PROHIBITED**.

**Empirical Proof Required**:
- File existence (strategy doc, index plan)
- Pattern matching (UNIQUE constraints in migration)
- Manual verification (index justification)

---

#### 2.4 Correlation & Audit Hooks (BLOCKING PHASE)

**Documentation Requirements** (MANDATORY):
1. Create `db/docs/CORRELATION_ID_SEMANTICS.md`:
   - How `correlation_id` propagates in ingest boundary
   - Stitching narrative: links `attribution_events`, `dead_events`, future `attribution_allocations`
   - Reconstruction rules for forensic analysis

2. Update DDL specs with column comments:
   - `COMMENT ON COLUMN attribution_events.correlation_id IS '...'`
   - `COMMENT ON COLUMN dead_events.correlation_id IS '...'`

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 2.4.1**: Correlation semantics document exists (`db/docs/CORRELATION_ID_SEMANTICS.md`)
- ✅ **Gate 2.4.2**: Stitching narrative documented (manual verification)
- ✅ **Gate 2.4.3**: Column comments present on all `correlation_id` columns (verified via `grep -r "COMMENT ON COLUMN.*correlation_id" db/docs/specs/` → matches for tables with correlation_id)
- ✅ **Gate 2.4.4**: Contract→schema mapping shows correlation linkage (update `contract_schema_mapping.yaml`)

**Blocking Condition**: If ANY exit gate fails, Phase 2.5 is **PROHIBITED**.

**Empirical Proof Required**:
- File existence
- Pattern matching (column comments)
- Manual verification (stitching narrative)

---

#### 2.5 Materialized Views (BLOCKING PHASE)

**Views Required** (per contract endpoints):
1. `mv_realtime_revenue`: Aggregates `total_revenue`, `verified`, `data_freshness_seconds` from `revenue_ledger` + `attribution_events`
2. `mv_reconciliation_status`: Aggregates `state`, `last_run_at` from `reconciliation_runs`

**Implementation Steps** (MANDATORY):
1. Create DDL spec: `db/docs/specs/mv_realtime_revenue_ddl_spec.sql`
2. Create DDL spec: `db/docs/specs/mv_reconciliation_status_ddl_spec.sql`
3. Create migration: `YYYYMMDDHHMM_add_materialized_views.py`
4. Test JSON shape compliance:
   - Query materialized view → Compare output to contract schema
   - Verify field names, types, required fields match contract

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 2.5.1**: Materialized view DDL specs exist (2 files)
- ✅ **Gate 2.5.2**: Migration file exists (`alembic/versions/YYYYMMDDHHMM_add_materialized_views.py`)
- ✅ **Gate 2.5.3**: Views produce contract-compliant JSON (tested via static SQL queries, verified against contract schemas)
- ✅ **Gate 2.5.4**: Indexes support p95 < 50ms target (documented in index plan)
- ✅ **Gate 2.5.5**: Refresh policy documented (CONCURRENTLY, TTL-based, in migration comments)

**Blocking Condition**: If ANY exit gate fails, Phase 3 is **PROHIBITED**.

**Empirical Proof Required**:
- File existence (specs, migration)
- Test execution (JSON shape compliance)
- Manual verification (refresh policy)

---

### Phase 3: RLS & Tenant Isolation (BLOCKING PHASE)

**Intent**: Enable RLS on all tenant-scoped tables with empirical validation.

#### 3.1 RLS Policy Application (BLOCKING PHASE)

**Steps** (MANDATORY):
1. Create migration: `YYYYMMDDHHMM_add_rls_policies.py` (or combine with core tables migration)
2. For each tenant-scoped table:
   - `ALTER TABLE ... ENABLE ROW LEVEL SECURITY;`
   - `ALTER TABLE ... FORCE ROW LEVEL SECURITY;`
   - `CREATE POLICY tenant_isolation_policy ON ... USING (tenant_id = current_setting('app.current_tenant_id')::uuid) WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid);`
3. Apply to: `attribution_events`, `dead_events`, `attribution_allocations`, `revenue_ledger`, `reconciliation_runs`

**Policy Validation** (per `DDL_LINT_RULES.md` Rule 5):
- Every table with `tenant_id` must have RLS enabled
- Every table with `tenant_id` must have RLS policy created
- Policy must use `current_setting('app.current_tenant_id')::uuid` pattern

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 3.1.1**: RLS migration file exists (or RLS in core tables migration)
- ✅ **Gate 3.1.2**: RLS enabled on all 5 tenant-scoped tables (verified via `grep -r "ENABLE ROW LEVEL SECURITY" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.1.3**: FORCE RLS enabled on all 5 tables (verified via `grep -r "FORCE ROW LEVEL SECURITY" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.1.4**: Policy created for all 5 tables (verified via `grep -r "CREATE POLICY tenant_isolation_policy" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.1.5**: All policies use `current_setting('app.current_tenant_id')::uuid` (verified via `grep -r "current_setting.*app.current_tenant_id" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.1.6**: Migration applies cleanly (`alembic upgrade head` → success)

**Blocking Condition**: If ANY exit gate fails, Phase 3.2 is **PROHIBITED**.

**Empirical Proof Required**:
- Pattern matching (ENABLE RLS, FORCE RLS, CREATE POLICY counts)
- Test execution (migration applies)

---

#### 3.2 GRANT Application (BLOCKING PHASE)

**Steps** (MANDATORY):
1. Create migration: `YYYYMMDDHHMM_add_grants.py` (or combine with RLS migration)
2. For each tenant-scoped table:
   - `GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ... TO app_rw;`
   - `GRANT SELECT ON TABLE ... TO app_ro;`
   - `REVOKE ALL ON TABLE ... FROM PUBLIC;`
3. Apply to: `attribution_events`, `dead_events`, `attribution_allocations`, `revenue_ledger`, `reconciliation_runs`

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 3.2.1**: GRANT migration file exists (or GRANTs in RLS migration)
- ✅ **Gate 3.2.2**: `app_rw` granted on all 5 tables (verified via `grep -r "GRANT.*TO app_rw" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.2.3**: `app_ro` granted on all 5 tables (verified via `grep -r "GRANT SELECT.*TO app_ro" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.2.4**: PUBLIC revoked on all 5 tables (verified via `grep -r "REVOKE.*FROM PUBLIC" alembic/versions/*.py` → 5 matches)
- ✅ **Gate 3.2.5**: Migration applies cleanly (`alembic upgrade head` → success)

**Blocking Condition**: If ANY exit gate fails, Phase 3.3 is **PROHIBITED**.

**Empirical Proof Required**:
- Pattern matching (GRANT/REVOKE counts)
- Test execution (migration applies)

---

#### 3.3 Empirical Validation (BLOCKING PHASE)

**Test Scripts** (MANDATORY - create `db/tests/test_rls_isolation.sql`):

1. **Cross-tenant denial test**:
   ```sql
   -- Setup: Create two tenants
   INSERT INTO tenants (id, name) VALUES 
       ('00000000-0000-0000-0000-000000000001', 'Tenant A'),
       ('00000000-0000-0000-0000-000000000002', 'Tenant B');
   
   -- Test: Tenant A cannot SELECT Tenant B data
   SET app.current_tenant_id = '00000000-0000-0000-0000-000000000001';
   SELECT * FROM attribution_events WHERE tenant_id = '00000000-0000-0000-0000-000000000002';
   -- Expected: 0 rows (RLS blocks cross-tenant access)
   
   -- Test: Tenant A cannot INSERT into Tenant B
   SET app.current_tenant_id = '00000000-0000-0000-0000-000000000001';
   INSERT INTO attribution_events (tenant_id, ...) VALUES ('00000000-0000-0000-0000-000000000002', ...);
   -- Expected: Error or 0 rows inserted (RLS blocks cross-tenant insert)
   ```

2. **GUC validation test**:
   ```sql
   -- Test: Unset GUC = no access
   RESET app.current_tenant_id;
   SELECT * FROM attribution_events;
   -- Expected: 0 rows (default-deny)
   ```

3. **Default-deny test**:
   ```sql
   -- Test: No policy bypass
   SET app.current_tenant_id = NULL;
   SELECT * FROM attribution_events;
   -- Expected: 0 rows or error
   ```

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 3.3.1**: Test script exists (`db/tests/test_rls_isolation.sql`)
- ✅ **Gate 3.3.2**: Cross-tenant denial test passes (Tenant A cannot access Tenant B data, verified via test execution)
- ✅ **Gate 3.3.3**: GUC validation test passes (unset GUC = no access, verified via test execution)
- ✅ **Gate 3.3.4**: Default-deny test passes (NULL GUC = no access, verified via test execution)
- ✅ **Gate 3.3.5**: Test results documented (`db/tests/test_rls_isolation_results.md`)

**Blocking Condition**: If ANY exit gate fails, Phase 4 is **PROHIBITED**.

**Empirical Proof Required**:
- File existence (test script, results doc)
- Test execution results (all tests pass)
- Manual verification (test results documented)

---

### Phase 4: Integration & Compliance (FINAL BLOCKING PHASE)

**Intent**: Verify system-level compliance and prepare for deployment.

**Actions** (MANDATORY):

1. **Contract Compliance Matrix**:
   - Complete `db/docs/contract_schema_mapping.yaml` with all 6 entities
   - Map every contract field to database column
   - Document type mappings, nullability, constraints

2. **Data Dictionary**:
   - Generate data dictionary (all tables, columns, constraints, indexes)
   - Save to `db/docs/data_dictionary/data_dictionary.md`

3. **ERD**:
   - Create/update ERD showing entity relationships
   - Save to `db/docs/erd/erd.md` or `db/docs/erd/erd.png`

4. **Migration Safety Verification**:
   - Verify all migrations follow `MIGRATION_SAFETY_CHECKLIST.md`
   - Test rollback on fresh database
   - Document timeouts, lock behavior

5. **Lint Validation**:
   - Run DDL lint tool (or manual verification per `DDL_LINT_RULES.md`)
   - Verify zero blocking errors
   - Document any warnings (with rationale)

6. **Static Query Tests**:
   - Test materialized views produce contract-compliant JSON
   - Save test queries to `db/tests/test_contract_compliance.sql`
   - Document test results

**Exit Gates (ALL MUST PASS - BLOCKING)**:
- ✅ **Gate 4.1**: Contract mapping complete (`contract_schema_mapping.yaml` has entries for all 6 entities, verified via grep)
- ✅ **Gate 4.2**: Data dictionary generated (`db/docs/data_dictionary/data_dictionary.md` exists, verified via file existence)
- ✅ **Gate 4.3**: ERD created (`db/docs/erd/erd.md` or `erd.png` exists, verified via file existence)
- ✅ **Gate 4.4**: Migration safety verified (all migrations follow safety checklist, documented in `db/docs/MIGRATION_SAFETY_VERIFICATION.md`)
- ✅ **Gate 4.5**: Lint passes (zero blocking errors, documented in `db/docs/LINT_VALIDATION_RESULTS.md`)
- ✅ **Gate 4.6**: Materialized view JSON compliance verified (test queries pass, documented in `db/tests/test_contract_compliance_results.md`)
- ✅ **Gate 4.7**: RLS isolation proven (test results from Phase 3.3 documented)

**Blocking Condition**: If ANY exit gate fails, **IMPLEMENTATION IS INCOMPLETE**. Must remediate before deployment.

**Empirical Proof Required**:
- File existence (all documentation files)
- Pattern matching (contract mapping completeness)
- Test execution results (all tests pass)
- Manual verification (documentation completeness)

---

## Part III: Critical Enforcement Rules

### Phase Advancement Prohibition

**RULE**: **NO PHASE CAN BE STARTED UNTIL ALL EXIT GATES OF THE PREVIOUS PHASE ARE VERIFIED AND DOCUMENTED.**

**Enforcement**:
1. Each phase has explicit exit gates with empirical verification requirements
2. Exit gates must be verified via:
   - File existence checks
   - Pattern matching (grep)
   - Test execution
   - Manual verification (documented)
3. If ANY exit gate fails, the next phase is **PROHIBITED**
4. Remediation must occur before phase advancement

### Empirical Proof Requirements

**RULE**: **ALL EXIT GATES REQUIRE EMPIRICAL PROOF, NOT ASSUMPTIONS.**

**Proof Types**:
1. **File Existence**: Verified via `ls` or file read
2. **Pattern Matching**: Verified via `grep` with expected match counts
3. **Test Execution**: Verified via actual test runs with documented results
4. **Manual Verification**: Documented in verification files

### Blocking Conditions

**RULE**: **BLOCKING CONDITIONS ARE ABSOLUTE - NO EXCEPTIONS.**

**Blocking Triggers**:
- Any exit gate failure
- Missing empirical proof
- Incomplete documentation
- Test failures

**Remediation Process**:
1. Identify blocking condition
2. Remediate issue
3. Re-verify exit gates
4. Document remediation
5. Only then proceed to next phase

---

## Part IV: Implementation Artifacts & File Locations

### Migration Files (to be created):
- `alembic/versions/YYYYMMDDHHMM_add_core_tables.py` - Core table DDL
- `alembic/versions/YYYYMMDDHHMM_add_rls_policies.py` - RLS policies (or combined)
- `alembic/versions/YYYYMMDDHHMM_add_grants.py` - GRANTs (or combined)
- `alembic/versions/YYYYMMDDHHMM_add_materialized_views.py` - Materialized views

### DDL Specification Files (to be created):
- `db/docs/specs/tenants_ddl_spec.sql`
- `db/docs/specs/attribution_events_ddl_spec.sql`
- `db/docs/specs/dead_events_ddl_spec.sql`
- `db/docs/specs/attribution_allocations_ddl_spec.sql`
- `db/docs/specs/revenue_ledger_ddl_spec.sql`
- `db/docs/specs/reconciliation_runs_ddl_spec.sql`
- `db/docs/specs/mv_realtime_revenue_ddl_spec.sql`
- `db/docs/specs/mv_reconciliation_status_ddl_spec.sql`

### Documentation Files (to be created/updated):
- `db/docs/IDEMPOTENCY_STRATEGY.md` - Idempotency strategy per source
- `db/docs/INDEX_PLAN.md` - Index justification per query path
- `db/docs/CORRELATION_ID_SEMANTICS.md` - Correlation ID semantics
- `db/docs/contract_schema_mapping.yaml` - Complete mapping matrix
- `db/docs/data_dictionary/data_dictionary.md` - Generated data dictionary
- `db/docs/erd/erd.md` or `erd.png` - Entity-relationship diagram
- `db/docs/MIGRATION_SAFETY_VERIFICATION.md` - Migration safety verification
- `db/docs/LINT_VALIDATION_RESULTS.md` - Lint validation results

### Test Scripts (to be created):
- `db/tests/test_rls_isolation.sql` - Cross-tenant denial tests
- `db/tests/test_rls_isolation_results.md` - Test results
- `db/tests/test_contract_compliance.sql` - Materialized view JSON shape tests
- `db/tests/test_contract_compliance_results.md` - Test results

---

## Part V: Execution Readiness Checklist

**Pre-Implementation** (Phase 1 - VERIFIED):
- [x] Governance baseline complete (`GOVERNANCE_BASELINE_CHECKLIST.md`)
- [x] Alembic configured (`alembic.ini`, `alembic/env.py`)
- [x] Style guide complete (`SCHEMA_STYLE_GUIDE.md`)
- [x] Contract mapping rulebook complete (`CONTRACT_TO_SCHEMA_MAPPING.md`)
- [x] RLS template exists (`rls_policy.py.template`)
- [x] Role matrix documented (`ROLES_AND_GRANTS.md`)
- [x] DDL lint rules defined (`DDL_LINT_RULES.md`)

**Implementation** (Phases 2-4 - PENDING):
- [ ] Phase 2.1: Core table DDL specs created (6 files) + ALL 9 exit gates passed
- [ ] Phase 2.2: Alembic migrations created and tested + ALL 8 exit gates passed
- [ ] Phase 2.3: Idempotency constraints and indexes defined + ALL 6 exit gates passed
- [ ] Phase 2.4: Correlation hooks documented + ALL 4 exit gates passed
- [ ] Phase 2.5: Materialized views created + ALL 5 exit gates passed
- [ ] Phase 3.1: RLS policies applied + ALL 6 exit gates passed
- [ ] Phase 3.2: GRANTs applied + ALL 5 exit gates passed
- [ ] Phase 3.3: Empirical validation complete + ALL 5 exit gates passed
- [ ] Phase 4: Integration & compliance verified + ALL 7 exit gates passed

**Post-Implementation** (Phase 4 - PENDING):
- [ ] Contract mapping matrix complete (all 6 entities)
- [ ] Data dictionary generated
- [ ] ERD created/updated
- [ ] Test scripts passing (all tests documented)
- [ ] Documentation reviewed and approved

---

## Conclusion

This refined plan enforces **absolute phase advancement prohibition** until all exit gates are empirically verified. Each phase has explicit, measurable exit gates with forensic validation requirements. **NO IMPLEMENTATION OR TASK ADVANCEMENT IS PERMITTED** until every phase is fully complete under these conditions.

**Next Steps**: Begin Phase 2.1 (Core Table DDL Specification) with strict adherence to exit gate requirements.



