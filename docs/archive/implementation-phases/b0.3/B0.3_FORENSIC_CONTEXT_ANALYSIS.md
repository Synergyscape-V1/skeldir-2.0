# B0.3 Forensic Context Analysis

**Analysis Date**: 2025-11-13  
**Analyst**: Independent Forensic Review  
**Purpose**: Empirical, code-level answers to all questions posed by Engineering Analysts Billy and Alex  
**Methodology**: Static code analysis, migration review, documentation inspection, dependency tracing

---

## Executive Summary

This document provides comprehensive, empirical answers to all clarification questions posed by Engineering Analysts Billy and Alex regarding B0.3 implementation gaps. All answers are grounded in static code analysis of migrations, documentation, and schema definitions.

**Key Findings**:
1. **Immutability Gap Confirmed**: `app_rw` has UPDATE/DELETE privileges on `attribution_events` and `revenue_ledger` (contradicts immutability mandate)
2. **Defense-in-Depth Gap Confirmed**: Guard triggers (`fn_events_prevent_mutation`, `fn_ledger_prevent_mutation`) are documented but absent from migrations
3. **Taxonomy Gap Confirmed**: `attribution_allocations` uses CHECK constraint instead of FK to `channel_taxonomy` table (which does not exist)

---

## Part 1: Answers to Engineering Analyst Billy's Questions

### Phase 1: Events & Ledger Immutability (GRANTs)

#### Question 1: Code Path (GRANTs)

**Question**: Please provide the static Python code block from the `upgrade()` function in `alembic/versions/202511131121_add_grants.py`. I specifically need to see the loop and the exact `op.execute(f"GRANT ...")` statements (ref: line 71, 74, 77) to confirm the full set of privileges applied.

**Answer**:

**File**: `alembic/versions/202511131121_add_grants.py`

**Full `upgrade()` function** (lines 53-88):

```python
def upgrade() -> None:
    """
    Apply GRANTs per ROLES_AND_GRANTS.md matrix.
    
    For each tenant-scoped table:
    1. GRANT SELECT, INSERT, UPDATE, DELETE TO app_rw
    2. GRANT SELECT TO app_ro
    3. REVOKE ALL FROM PUBLIC
    
    For materialized views:
    1. GRANT SELECT TO app_rw
    2. GRANT SELECT TO app_ro
    3. REVOKE ALL FROM PUBLIC
    """
    
    # Grant permissions on tenant-scoped tables
    for table_name in TENANT_SCOPED_TABLES:
        # Grant to app_rw (read-write)
        op.execute(f"GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE {table_name} TO app_rw")
        
        # Grant to app_ro (read-only)
        op.execute(f"GRANT SELECT ON TABLE {table_name} TO app_ro")
        
        # Revoke PUBLIC access
        op.execute(f"REVOKE ALL ON TABLE {table_name} FROM PUBLIC")
    
    # Grant permissions on materialized views
    for view_name in MATERIALIZED_VIEWS:
        # Grant to app_rw (read)
        op.execute(f"GRANT SELECT ON TABLE {view_name} TO app_rw")
        
        # Grant to app_ro (read-only)
        op.execute(f"GRANT SELECT ON TABLE {view_name} TO app_ro")
        
        # Revoke PUBLIC access
        op.execute(f"REVOKE ALL ON TABLE {view_name} FROM PUBLIC")
```

**TENANT_SCOPED_TABLES list** (lines 38-44):
```python
TENANT_SCOPED_TABLES = [
    'attribution_events',
    'dead_events',
    'attribution_allocations',
    'revenue_ledger',
    'reconciliation_runs'
]
```

**Exact GRANT statements for `attribution_events` and `revenue_ledger`**:
- **Line 71**: `GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE {table_name} TO app_rw`
  - For `attribution_events`: `GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE attribution_events TO app_rw`
  - For `revenue_ledger`: `GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE revenue_ledger TO app_rw`
- **Line 74**: `GRANT SELECT ON TABLE {table_name} TO app_ro`
- **Line 77**: `REVOKE ALL ON TABLE {table_name} FROM PUBLIC`

**Empirical Finding**: The migration explicitly grants `UPDATE` and `DELETE` privileges to `app_rw` on both `attribution_events` and `revenue_ledger`, directly contradicting the immutability mandate.

---

#### Question 2: Artifact Review (GRANTs)

**Question**: Aside from `...1121_add_grants.py`, does a static review of any *other* migration file in the `alembic/versions/` directory show `REVOKE UPDATE` or `REVOKE DELETE` statements being applied to `app_rw` for `attribution_events` or `revenue_ledger`?

**Answer**:

**Methodology**: Searched all migration files in `alembic/versions/` for patterns:
- `REVOKE.*UPDATE`
- `REVOKE.*DELETE`

**Migration Files Reviewed**:
1. `202511121302_baseline.py`
2. `202511131115_add_core_tables.py`
3. `202511131119_add_materialized_views.py`
4. `202511131120_add_rls_policies.py`
5. `202511131121_add_grants.py`
6. `202511131232_enhance_allocation_schema.py`
7. `202511131240_add_sum_equality_validation.py`
8. `202511131250_enhance_revenue_ledger.py`

**Result**: **NO MATCHES FOUND**

**Empirical Finding**: No migration file contains `REVOKE UPDATE` or `REVOKE DELETE` statements for `app_rw` on `attribution_events` or `revenue_ledger`. The privileges granted in `202511131121_add_grants.py` remain unrevoked.

---

#### Question 3: Data Flow (Ledger Traceability)

**Question**: The `48. ...Foundation - I.md` document (Phase 2.4) leaves the `allocation_id` nullability on `revenue_ledger` as an open decision. To finalize this, please confirm from a static review of the application-level ingestion logic (e.g., webhook services): Does the application code *ever* intentionally create a `revenue_ledger` entry where `allocation_id` is `NULL` (e.g., for bank fees or non-allocation-based adjustments)?

**Answer**:

**Methodology**: 
1. Searched for application code that creates `revenue_ledger` entries
2. Reviewed backend directory structure
3. Searched for webhook services or ingestion logic

**Backend Directory Structure**:
- `backend/` contains only `README.md` (no application code found)
- No Python application code exists in the repository for webhook services or ingestion logic

**Schema Definition Review**:
- **File**: `alembic/versions/202511131250_enhance_revenue_ledger.py`
- **Line 48**: `ADD COLUMN allocation_id uuid REFERENCES attribution_allocations(id) ON DELETE CASCADE`
- **Note**: Column is nullable (no `NOT NULL` constraint)

**Documentation Review**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 2.4, lines 558-621)
- **Documented Use Cases for NULL `allocation_id`**:
  - Bank fees (not tied to specific allocation)
  - Adjustments (manual corrections not tied to allocation)
  - Reconciliation adjustments (run-based postings without allocation)

**Empirical Finding**: 
- **No application code exists** to review for intentional NULL `allocation_id` usage
- **Schema allows NULL**: `allocation_id` is nullable per migration `202511131250_enhance_revenue_ledger.py:48`
- **Documentation suggests NULL is intended**: Phase 2.4 documents use cases for NULL `allocation_id` (bank fees, adjustments, reconciliation adjustments)
- **Decision Required**: The documentation presents two options (Option A: NOT NULL, Option B: NULL with CHECK constraint), but no decision has been finalized in code

**Conclusion**: Cannot empirically confirm from application code (none exists), but schema and documentation suggest NULL `allocation_id` is intentionally supported for non-allocation-based postings.

---

### Phase 2: Events & Ledger Immutability (Triggers)

#### Question 4: Artifact Review (Triggers)

**Question**: Please confirm via static review of all migration files in `alembic/versions/`: Do the function `fn_events_prevent_mutation` or the trigger `trg_events_prevent_mutation` exist in *any* `upgrade()` function?

**Answer**:

**Methodology**: Searched all migration files for:
- `fn_events_prevent_mutation`
- `trg_events_prevent_mutation`

**Migration Files Reviewed**:
1. `202511121302_baseline.py`
2. `202511131115_add_core_tables.py`
3. `202511131119_add_materialized_views.py`
4. `202511131120_add_rls_policies.py`
5. `202511131121_add_grants.py`
6. `202511131232_enhance_allocation_schema.py`
7. `202511131240_add_sum_equality_validation.py`
8. `202511131250_enhance_revenue_ledger.py`

**Result**: **NO MATCHES FOUND**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 1.4, lines 354-408)
- **Status**: "✅ **SPECIFIED** (Phase 1.4 complete)"
- **Specification**: Function and trigger are fully specified but **not implemented** in any migration

**Empirical Finding**: The guard trigger `fn_events_prevent_mutation` and `trg_events_prevent_mutation` are **documented as required** but **absent from all migration files**. This confirms the "Defense-in-Depth Gap" identified in the forensic analysis.

---

#### Question 5: Artifact Review (Triggers)

**Question**: Similarly, please confirm via static review if *any* migration file implements `fn_ledger_prevent_mutation` or `trg_ledger_prevent_mutation`.

**Answer**:

**Methodology**: Searched all migration files for:
- `fn_ledger_prevent_mutation`
- `trg_ledger_prevent_mutation`

**Migration Files Reviewed**: (Same as Question 4)

**Result**: **NO MATCHES FOUND**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 2.6, lines 688-746)
- **Status**: "✅ **DOCUMENTED** (Phase 2.6 complete)"
- **Specification**: Function and trigger are fully specified but **not implemented** in any migration

**Empirical Finding**: The guard trigger `fn_ledger_prevent_mutation` and `trg_ledger_prevent_mutation` are **documented as required** but **absent from all migration files**. This confirms the "Defense-in-Depth Gap" for ledger immutability.

---

### Phase 3: Canonical Channel Taxonomy (FK vs. CHECK)

#### Question 6: Code Path (CHECK Constraint)

**Question**: Please provide the static SQL DDL or Python `op.create_check_constraint` block from `alembic/versions/202511131232_enhance_allocation_schema.py`. I need the *exact list of channels* defined within the `ck_attribution_allocations_channel_code_valid` constraint.

**Answer**:

**File**: `alembic/versions/202511131232_enhance_allocation_schema.py`

**CHECK Constraint Definition** (lines 78-92):

```python
# Add channel_code validation (CHECK constraint)
# NOTE: Channel codes deferred to contract review. Using common codes as placeholder.
# This should be updated once contracts define the channel_code enum.
op.execute("""
    ALTER TABLE attribution_allocations
        ADD CONSTRAINT ck_attribution_allocations_channel_code_valid
        CHECK (channel IN (
            'google_search',
            'facebook_ads',
            'direct',
            'email',
            'organic',
            'referral',
            'social',
            'paid_search',
            'display'
        ))
""")
```

**Exact List of Channels** (hardcoded in CHECK constraint):
1. `'google_search'`
2. `'facebook_ads'`
3. `'direct'`
4. `'email'`
5. `'organic'`
6. `'referral'`
7. `'social'`
8. `'paid_search'`
9. `'display'`

**Empirical Finding**: The CHECK constraint contains a hardcoded list of 9 channel values, directly contradicting the mandate to use a canonical `channel_taxonomy` table with a FOREIGN KEY constraint.

---

#### Question 7: Artifact Review (Taxonomy Table)

**Question**: Please confirm via static review of all migration files: does a file exist that creates the `channel_taxonomy` table and applies a `FOREIGN KEY` constraint from `attribution_allocations` to it?

**Answer**:

**Methodology**: Searched all migration files for:
- `channel_taxonomy`
- `CREATE TABLE.*channel_taxonomy`
- `FOREIGN KEY.*channel_taxonomy`

**Migration Files Reviewed**: (Same as Question 4)

**Result**: **NO MATCHES FOUND**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2, lines 832-880)
- **Status**: "✅ **DOCUMENTED** (Phase 3.2 complete)"
- **Specification**: `channel_taxonomy` table is fully specified but **not implemented** in any migration

**Empirical Finding**: The `channel_taxonomy` table does **not exist** in any migration file. This confirms the "Taxonomy Gap" identified in the forensic analysis.

---

#### Question 8: Artifact Review (Mapping File)

**Question**: The B0.3 spec (`48. ...`, Phase 3.4) mandates a `db/channel_mapping.yaml` file as the SoT for vendor-to-canonical mapping. Please provide the *full static contents* of this YAML file.

**Answer**:

**File**: `db/channel_mapping.yaml`

**Full Contents**:

```yaml
# Vendor → Canonical Channel Mapping
# Source of Truth for ingestion service normalization
#
# Purpose: Map vendor-specific channel indicators to canonical channel codes
# Usage: B0.4 ingestion service reads this file and maps incoming channel indicators
#        to channel_taxonomy.code before inserting into attribution_allocations
#
# Structure:
#   sources:
#     <vendor_name>:
#       "<vendor_channel_indicator>": <canonical_channel_code>
#
# Example:
#   sources:
#     facebook_ads:
#       "FB_ADS": facebook_paid
#       "FB_BRAND": facebook_brand

sources:
  facebook_ads:
    "FB_ADS": facebook_paid
    "FB_BRAND": facebook_brand
    "FACEBOOK_ADS": facebook_paid
  
  google_ads:
    "SEARCH": google_search_paid
    "DISPLAY": google_display_paid
    "GOOGLE_SEARCH": google_search_paid
    "GOOGLE_DISPLAY": google_display_paid
  
  tiktok_ads:
    "IN_FEED": tiktok_paid
    "TIKTOK_ADS": tiktok_paid
  
  shopify:
    "DIRECT": direct
    "ORGANIC": organic
    "REFERRAL": referral
  
  stripe:
    "DIRECT": direct
    "EMAIL": email
  
  paypal:
    "DIRECT": direct
    "REFERRAL": referral
  
  woocommerce:
    "DIRECT": direct
    "ORGANIC": organic
    "EMAIL": email

# Notes:
# - All canonical channel codes must exist in channel_taxonomy.code
# - Vendor channel indicators are case-sensitive (as provided by vendor APIs)
# - Multiple vendor indicators can map to the same canonical code
# - New vendors/channels require update to both this file and channel_taxonomy table
```

**Empirical Finding**: The mapping file exists and is well-structured, but it references `channel_taxonomy.code` which does not exist in the database schema (per Question 7). The mapping file is ready for use once the `channel_taxonomy` table is created.

---

## Part 2: Answers to Engineering Analyst Alex's Questions

### A. Source-of-Truth and Repo Structure

#### Q1.1: Canonical Repo & Modules

**Question**: Which repository (and subdirectories) should be treated as the **canonical source of truth** for:
- Database migrations?
- SQL functions, triggers, and RLS policies?
- Application-level DB access code (ORM, query builders, etc.)?

**Answer**:

**Canonical Source of Truth**:

1. **Database Migrations**:
   - **Location**: `alembic/versions/`
   - **Files**: All `.py` files in this directory are versioned migrations
   - **Ordering**: Migrations are ordered by revision ID (timestamp-based)
   - **Current Migrations**:
     - `202511121302_baseline.py`
     - `202511131115_add_core_tables.py`
     - `202511131119_add_materialized_views.py`
     - `202511131120_add_rls_policies.py`
     - `202511131121_add_grants.py`
     - `202511131232_enhance_allocation_schema.py`
     - `202511131240_add_sum_equality_validation.py`
     - `202511131250_enhance_revenue_ledger.py`

2. **SQL Functions, Triggers, and RLS Policies**:
   - **Location**: `alembic/versions/` (embedded in migration files)
   - **RLS Policies**: `alembic/versions/202511131120_add_rls_policies.py`
   - **Triggers**: Currently only `check_allocation_sum()` in `202511131240_add_sum_equality_validation.py`
   - **Guard Triggers**: Documented but not implemented (see Questions 4-5)

3. **Application-Level DB Access Code**:
   - **Location**: `backend/` directory
   - **Current State**: **EMPTY** (only `README.md` exists)
   - **Finding**: No application code exists in the repository

**Empirical Finding**: The repository structure is database-migration-centric. Application code does not exist, suggesting B0.3 is purely a database schema foundation phase.

---

#### Q1.2: Legacy or Deprecated Modules

**Question**: Are there *any* legacy or deprecated modules/migrations still present in the repo that you consider **non-authoritative** for B0.3 but are still checked in? If yes, list them or describe where they live.

**Answer**:

**Methodology**: Reviewed all migration files and documentation for deprecation markers or legacy indicators.

**Migration Files Reviewed**: All 8 migration files in `alembic/versions/`

**Result**: **NO LEGACY OR DEPRECATED MODULES IDENTIFIED**

**All migrations appear authoritative**:
- All migrations follow consistent naming and structure
- All migrations have proper revision chains
- No deprecation comments or legacy markers found
- All migrations are referenced in `B0.3_IMPLEMENTATION_COMPLETE.md`

**Empirical Finding**: All migrations in `alembic/versions/` appear to be authoritative for B0.3. No legacy or deprecated modules identified.

---

#### Q1.3: Current "Readiness" Documentation

**Question**: Apart from `49. Operational Handover B0.3 Closeout.md`, are there any other documents you currently treat as de facto readiness or status records for B0.3 (e.g., Notion pages, ADRs, internal markdowns, ticket descriptions)?

**Answer**:

**Methodology**: Searched for readiness, status, or closeout documentation.

**Documents Found**:

1. **`B0.3_IMPLEMENTATION_COMPLETE.md`**:
   - **Status**: "✅ **COMPLETE** (All phases implemented, pending execution verification)"
   - **Content**: Comprehensive implementation record with all phases documented
   - **Authority**: Primary implementation record

2. **`B0.3_SCOPE.md`**:
   - **Content**: B0.3 scope and object inventory
   - **Authority**: Scope definition document

3. **`B0.3_REFINED_IMPLEMENTATION_PLAN.md`**:
   - **Content**: Refined implementation plan
   - **Authority**: Planning document

4. **`B0.3_Forensic_Analysis.md`**:
   - **Content**: Forensic analysis of B0.3 gaps
   - **Authority**: Analysis document

5. **`B0.3_FORENSIC_ANALYSIS_RESPONSE.md`**:
   - **Content**: Response to forensic analysis
   - **Authority**: Response document

6. **`db/GOVERNANCE_BASELINE_CHECKLIST.md`**:
   - **Content**: Governance baseline checklist
   - **Authority**: Governance document

**Empirical Finding**: `B0.3_IMPLEMENTATION_COMPLETE.md` is the primary readiness record, but it explicitly states "pending execution verification" - indicating B0.3 is not empirically closed.

---

#### Q1.4: Most Accurate Readiness Document

**Question**: If yes, which one(s) do you personally consider **most accurate right now**, and what specific aspects of B0.3 do they cover (events, ledger, channels, RLS, tests, etc.)?

**Answer**:

**Most Accurate Readiness Document**: `B0.3_IMPLEMENTATION_COMPLETE.md`

**Coverage**:

1. **Events Immutability**:
   - Phase 1.1: Current privilege state (documented)
   - Phase 1.3: GRANT realignment spec (specified, not implemented)
   - Phase 1.4: Guard trigger spec (specified, not implemented)
   - **Gap**: Specified but not implemented

2. **Ledger Immutability**:
   - Phase 2.1-2.7: Complete specification
   - Phase 2.5: GRANT realignment spec (specified, not implemented)
   - Phase 2.6: Guard trigger spec (specified, not implemented)
   - **Gap**: Specified but not implemented

3. **Channel Taxonomy**:
   - Phase 3.1-3.6: Complete specification
   - Phase 3.2: Taxonomy table spec (specified, not implemented)
   - Phase 3.3: FK binding spec (specified, not implemented)
   - **Gap**: Specified but not implemented

4. **RLS**:
   - Phase 3.1: RLS policies (implemented in `202511131120_add_rls_policies.py`)
   - **Status**: ✅ Implemented

5. **Tests**:
   - Test scripts exist but marked as "pending execution"
   - **Status**: ⏳ Created but not executed

**Empirical Finding**: The document is comprehensive but explicitly acknowledges gaps between specification and implementation. It is the most accurate record but confirms B0.3 is in "mixed state."

---

#### Q1.5: Conflicting Sources

**Question**: From your perspective, where do you see **the most significant conflicts or drift** between:
- Architecture guides,
- Phase docs,
- Actual migrations/schema,
- And the current app code?

**Answer**:

**Most Significant Conflicts**:

1. **Immutability Policy vs. GRANTs**:
   - **Policy**: `db/docs/EVENTS_IMMUTABILITY_POLICY.md` states events are immutable
   - **Migrations**: `202511131121_add_grants.py` grants UPDATE/DELETE to `app_rw`
   - **Conflict**: Policy mandates immutability, but GRANTs allow mutation

2. **Channel Taxonomy Specification vs. Implementation**:
   - **Specification**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2) specifies `channel_taxonomy` table
   - **Implementation**: `202511131232_enhance_allocation_schema.py` uses CHECK constraint with hardcoded values
   - **Conflict**: Specification mandates FK to taxonomy table, but implementation uses CHECK constraint

3. **Guard Triggers Specification vs. Implementation**:
   - **Specification**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phases 1.4, 2.6) specifies guard triggers
   - **Implementation**: No migration creates these triggers
   - **Conflict**: Specification mandates defense-in-depth triggers, but none exist

4. **Application Code**:
   - **Expected**: Application code should exist for webhook ingestion
   - **Reality**: `backend/` directory is empty (only `README.md`)
   - **Conflict**: No application code exists to validate schema assumptions

**Empirical Finding**: The primary conflict is between **specification documents** (which mandate immutability, taxonomy table, and guard triggers) and **actual migrations** (which grant mutation privileges, use CHECK constraints, and lack guard triggers).

---

#### Q1.6: Concrete Example of Conflict

**Question**: Can you cite at least one **concrete example** of such a conflict (e.g., "doc says X about `attribution_events`, but migration Y does Z instead")?

**Answer**:

**Concrete Example 1: Events Immutability**

- **Documentation**: `db/docs/EVENTS_IMMUTABILITY_POLICY.md` (line 11):
  > "**`attribution_events` rows are immutable** - once an event is created, it cannot be updated or deleted by application roles."

- **Migration**: `alembic/versions/202511131121_add_grants.py` (line 71):
  ```python
  op.execute(f"GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE {table_name} TO app_rw")
  ```
  - For `attribution_events`: Grants UPDATE and DELETE to `app_rw`

- **Conflict**: Policy states immutability, but migration grants mutation privileges.

**Concrete Example 2: Channel Taxonomy**

- **Documentation**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2, lines 839-847):
  ```sql
  CREATE TABLE channel_taxonomy (
      code          text PRIMARY KEY,
      family        text NOT NULL,
      ...
  );
  ```

- **Migration**: `alembic/versions/202511131232_enhance_allocation_schema.py` (lines 78-92):
  ```python
  op.execute("""
      ALTER TABLE attribution_allocations
          ADD CONSTRAINT ck_attribution_allocations_channel_code_valid
          CHECK (channel IN (
              'google_search',
              'facebook_ads',
              ...
          ))
  """)
  ```

- **Conflict**: Specification mandates `channel_taxonomy` table with FK, but migration uses CHECK constraint with hardcoded values.

---

### B. `attribution_events` – Immutability & Structure

#### Q2.1: Table Definition & Fields

**Question**: Which exact migration file(s) define the current `attribution_events` table (or the equivalent canonical events table)? Please specify file paths or identifiers you recognize.

**Answer**:

**Primary Definition**: `alembic/versions/202511131115_add_core_tables.py`

**Table Creation** (lines 99-152):

```python
# Create attribution_events table
op.execute("""
    CREATE TABLE attribution_events (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
        created_at timestamptz NOT NULL DEFAULT now(),
        updated_at timestamptz NOT NULL DEFAULT now(),
        occurred_at timestamptz NOT NULL,
        external_event_id text,
        correlation_id uuid,
        session_id uuid,
        revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (revenue_cents >= 0),
        raw_payload jsonb NOT NULL
    )
""")
```

**Columns Defined**:
1. `id uuid PRIMARY KEY`
2. `tenant_id uuid NOT NULL` (FK to `tenants`)
3. `created_at timestamptz NOT NULL`
4. `updated_at timestamptz NOT NULL`
5. `occurred_at timestamptz NOT NULL`
6. `external_event_id text` (nullable)
7. `correlation_id uuid` (nullable)
8. `session_id uuid` (nullable)
9. `revenue_cents INTEGER NOT NULL` (CHECK >= 0)
10. `raw_payload jsonb NOT NULL`

**Indexes Created** (lines 121-142):
- `idx_attribution_events_tenant_external_event_id` (UNIQUE, partial)
- `idx_attribution_events_tenant_correlation_id` (UNIQUE, partial)
- `idx_attribution_events_tenant_occurred_at`
- `idx_attribution_events_session_id` (partial)

**Empirical Finding**: `attribution_events` is defined in a single migration file with no subsequent schema changes.

---

#### Q2.2: Other Event-Like Tables

**Question**: Are there **any other tables** that store event-like records that you consider part of the attribution events model (e.g., staging, dead-letter, archival)? If yes, list them conceptually.

**Answer**:

**Related Tables**:

1. **`dead_events`**:
   - **File**: `alembic/versions/202511131115_add_core_tables.py` (lines 154-190)
   - **Purpose**: Dead-letter queue for invalid/unparseable webhook payloads
   - **Relationship**: Stores failed ingestion attempts
   - **Columns**: `id`, `tenant_id`, `ingested_at`, `source`, `error_code`, `error_detail`, `raw_payload`, `correlation_id`, `external_event_id`

**Empirical Finding**: Only `dead_events` is a related event-like table. No staging or archival tables exist.

---

#### Q2.3: Immutability Enforcement

**Question**: As currently implemented in migrations and SQL:
- Which DB roles are allowed to INSERT into `attribution_events`?
- Which roles, if any, have explicit UPDATE or DELETE privileges on this table?

**Answer**:

**GRANTs Applied**: `alembic/versions/202511131121_add_grants.py`

**INSERT Privileges**:
- **`app_rw`**: ✅ INSERT granted (line 71: `GRANT SELECT, INSERT, UPDATE, DELETE ...`)
- **`app_ro`**: ❌ INSERT not granted (line 74: `GRANT SELECT ...` only)
- **`migration_owner`**: ✅ INSERT (implicit, migration execution role)

**UPDATE Privileges**:
- **`app_rw`**: ✅ UPDATE granted (line 71: `GRANT SELECT, INSERT, UPDATE, DELETE ...`)
- **`app_ro`**: ❌ UPDATE not granted
- **`migration_owner`**: ✅ UPDATE (implicit)

**DELETE Privileges**:
- **`app_rw`**: ✅ DELETE granted (line 71: `GRANT SELECT, INSERT, UPDATE, DELETE ...`)
- **`app_ro`**: ❌ DELETE not granted
- **`migration_owner`**: ✅ DELETE (implicit)

**Empirical Finding**: `app_rw` has full CRUD privileges (including UPDATE and DELETE), contradicting immutability policy.

---

#### Q2.4: Triggers for Immutability

**Question**: Are there any **triggers or trigger functions** defined on `attribution_events` intended to enforce immutability (e.g., rejecting UPDATE/DELETE)? If yes:
- What is the function name?
- In which file(s) is it defined?

**Answer**:

**Methodology**: Searched all migration files for triggers on `attribution_events`.

**Result**: **NO TRIGGERS FOUND**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 1.4, lines 354-408)
- **Specified Function**: `fn_events_prevent_mutation()`
- **Specified Trigger**: `trg_events_prevent_mutation`
- **Status**: "✅ **SPECIFIED** (Phase 1.4 complete)" but **NOT IMPLEMENTED**

**Empirical Finding**: No immutability triggers exist on `attribution_events`. The guard trigger is specified but not implemented.

---

#### Q2.5: Privileges + Triggers Combination

**Question**: Based on your last static review, does the combination of privileges + triggers **actually prevent UPDATE/DELETE for app-facing roles**, or is immutability still partially "convention-based" in some paths?

**Answer**:

**Current State**:
- **Privileges**: `app_rw` has UPDATE and DELETE (per Q2.3)
- **Triggers**: None exist (per Q2.4)

**Empirical Finding**: **Immutability is entirely convention-based**. There is no database-level enforcement:
- GRANTs allow UPDATE/DELETE
- No triggers prevent mutation
- Immutability relies solely on application code compliance (which doesn't exist)

**Conclusion**: Immutability is **not enforced at the database level**. It is purely a documented policy with no enforcement mechanisms.

---

#### Q2.6: Application-Level UPDATE/DELETE

**Question**: In the application code (ORM/queries), are there *any* code paths that call UPDATE or DELETE against `attribution_events` (even if "not supposed to be used")?

**Answer**:

**Methodology**: Searched for application code in `backend/` directory.

**Result**: **NO APPLICATION CODE EXISTS**

**Backend Directory**: Contains only `README.md`

**Empirical Finding**: Cannot determine if application code calls UPDATE/DELETE because no application code exists in the repository.

---

#### Q2.7: Manual Corrections

**Question**: Have you ever had to manually or programmatically correct events by mutating existing rows (as opposed to inserting new corrective rows)? If yes, how was that done and is that pattern still present in the code?

**Answer**:

**Methodology**: Searched for correction patterns, manual fixes, or mutation scripts.

**Result**: **NO EVIDENCE FOUND**

**Empirical Finding**: No evidence of manual correction patterns in code or documentation. The policy document (`db/docs/EVENTS_IMMUTABILITY_POLICY.md`) specifies correction via new events, but no implementation exists.

---

#### Q2.8: Event Identity

**Question**: What is the **canonical identity** for an event row (e.g., DB PK only, or external `event_id`, or composite keys)?

**Answer**:

**Primary Key**: `id uuid PRIMARY KEY` (line 101)

**Idempotency Constraints** (lines 121-131):

1. **UNIQUE on `(tenant_id, external_event_id)`** (where `external_event_id IS NOT NULL`):
   ```sql
   CREATE UNIQUE INDEX idx_attribution_events_tenant_external_event_id 
       ON attribution_events (tenant_id, external_event_id) 
       WHERE external_event_id IS NOT NULL
   ```

2. **UNIQUE on `(tenant_id, correlation_id)`** (where `correlation_id IS NOT NULL` AND `external_event_id IS NULL`):
   ```sql
   CREATE UNIQUE INDEX idx_attribution_events_tenant_correlation_id 
       ON attribution_events (tenant_id, correlation_id) 
       WHERE correlation_id IS NOT NULL AND external_event_id IS NULL
   ```

**Canonical Identity**:
- **Database Identity**: `id uuid` (PRIMARY KEY)
- **Business Identity**: 
  - `(tenant_id, external_event_id)` when `external_event_id` is provided
  - `(tenant_id, correlation_id)` when `external_event_id` is NULL

**Empirical Finding**: Event identity is composite: database uses `id`, but idempotency is enforced via `(tenant_id, external_event_id)` or `(tenant_id, correlation_id)`.

---

#### Q2.9: Check Constraints or FKs

**Question**: Are there **check constraints** or FKs on critical columns (e.g., tenant, timestamp, channel, external source) that you rely on in practice, even if not fully documented in B0.3?

**Answer**:

**Constraints Defined**:

1. **Foreign Key**: `tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE` (line 102)

2. **Check Constraint**: `revenue_cents >= 0` (lines 109, 116-118):
   ```sql
   revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (revenue_cents >= 0)
   ALTER TABLE attribution_events 
       ADD CONSTRAINT ck_attribution_events_revenue_positive 
       CHECK (revenue_cents >= 0)
   ```

**No Constraints On**:
- `occurred_at` (no CHECK for valid timestamp range)
- `external_event_id` (no format validation)
- `correlation_id` (no FK or format validation)
- `session_id` (no FK or format validation)
- `raw_payload` (no JSON schema validation)

**Empirical Finding**: Only `tenant_id` FK and `revenue_cents` CHECK constraint exist. No constraints on timestamps, channel, or external source fields.

---

### C. `revenue_ledger` – Ledger Behavior and Corrections

#### Q3.1: Table Definition

**Question**: Which migration(s) define the `revenue_ledger` table (or its canonical equivalent)?

**Answer**:

**Primary Definition**: `alembic/versions/202511131115_add_core_tables.py` (lines 238-272)

**Initial Schema**:
```sql
CREATE TABLE revenue_ledger (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    revenue_cents INTEGER NOT NULL DEFAULT 0 CHECK (revenue_cents >= 0),
    is_verified boolean NOT NULL DEFAULT false,
    verified_at timestamptz,
    reconciliation_run_id uuid
)
```

**Enhancement Migration**: `alembic/versions/202511131250_enhance_revenue_ledger.py`

**Added Columns** (lines 46-65):
- `allocation_id uuid REFERENCES attribution_allocations(id) ON DELETE CASCADE` (nullable)
- `posted_at timestamptz NOT NULL DEFAULT now()`

**Added Index** (lines 68-77):
- `idx_revenue_ledger_tenant_allocation_id` (UNIQUE, partial: `WHERE allocation_id IS NOT NULL`)

**Empirical Finding**: `revenue_ledger` is defined in two migrations: initial creation and enhancement.

---

#### Q3.2: Other Ledger Tables

**Question**: Are there any **other tables** that you conceptually treat as part of the "ledger," such as adjustment tables, mapping tables, or staging tables? If yes, list them.

**Answer**:

**Methodology**: Searched for tables with "ledger", "adjustment", "mapping", or "staging" in name or purpose.

**Result**: **NO RELATED TABLES FOUND**

**Empirical Finding**: `revenue_ledger` is the only ledger table. No adjustment, mapping, or staging tables exist.

---

#### Q3.3: Ledger Immutability Privileges

**Question**: At the DB level, what privileges are currently granted for `revenue_ledger`:
- For app-level roles?
- For admin/system roles?

**Answer**:

**GRANTs Applied**: `alembic/versions/202511131121_add_grants.py` (line 71)

**App-Level Roles**:
- **`app_rw`**: `SELECT, INSERT, UPDATE, DELETE` (full CRUD)
- **`app_ro`**: `SELECT` only

**Admin/System Roles**:
- **`migration_owner`**: Full access (implicit, migration execution role)
- **`app_admin`**: Not explicitly granted (per `ROLES_AND_GRANTS.md`, should have admin table access, but `revenue_ledger` is tenant-scoped)

**Empirical Finding**: `app_rw` has full CRUD privileges, contradicting ledger immutability policy.

---

#### Q3.4: Ledger Immutability Triggers

**Question**: Are there triggers/trigger functions in place meant to enforce "no UPDATE/DELETE" behavior for the ledger? If yes:
- What are their names and where are they defined?

**Answer**:

**Methodology**: Searched all migration files for triggers on `revenue_ledger`.

**Result**: **NO TRIGGERS FOUND**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 2.6, lines 688-746)
- **Specified Function**: `fn_ledger_prevent_mutation()`
- **Specified Trigger**: `trg_ledger_prevent_mutation`
- **Status**: "✅ **DOCUMENTED** (Phase 2.6 complete)" but **NOT IMPLEMENTED**

**Empirical Finding**: No immutability triggers exist on `revenue_ledger`. The guard trigger is specified but not implemented.

---

#### Q3.5: Immutability Enforcement Status

**Question**: From your last inspection, is immutability fully enforced for the ledger, or are there still pathways where rows can be updated/deleted (e.g., migrations, admin scripts, background jobs)?

**Answer**:

**Current State**:
- **Privileges**: `app_rw` has UPDATE and DELETE (per Q3.3)
- **Triggers**: None exist (per Q3.4)
- **RLS**: Enabled (per `202511131120_add_rls_policies.py`), but RLS does not prevent UPDATE/DELETE, only filters rows

**Pathways for Mutation**:
1. **Application Role (`app_rw`)**: Can UPDATE/DELETE (privileges granted)
2. **Migration Role (`migration_owner`)**: Can UPDATE/DELETE (implicit)
3. **Admin Scripts**: No admin scripts found, but `migration_owner` role could be used

**Empirical Finding**: **Immutability is not enforced**. Multiple pathways exist for mutation:
- Application code can UPDATE/DELETE via `app_rw`
- Migrations can UPDATE/DELETE via `migration_owner`
- No triggers prevent mutation

---

#### Q3.6: Correction Patterns

**Question**: In actual code, how do you currently handle **corrections** when a ledger entry is wrong?
- Do you insert a reversing entry and a new corrected entry?
- Or do any paths still UPDATE the existing row?

**Answer**:

**Methodology**: Searched for correction patterns, reversal logic, or ledger correction code.

**Result**: **NO APPLICATION CODE EXISTS**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 2.1, lines 440-452)
- **Specified Pattern**: "Additive Corrections" (new ledger entries with negative `revenue_cents`)
- **Status**: Documented but not implemented

**Empirical Finding**: Cannot determine correction patterns from code (none exists). Documentation specifies additive corrections, but no implementation exists.

---

#### Q3.7: Standardized Correction Fields

**Question**: Is there a **standardized field set** you use to mark reversals or links between original and correction rows (e.g., `reverses_entry_id`, `correction_reason`)? If yes, where is this documented?

**Answer**:

**Schema Review**: `revenue_ledger` table columns (per Q3.1):
- No `reverses_entry_id` column
- No `correction_reason` column
- No explicit correction linking fields

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 2.1, lines 440-446)
- **Specified Pattern**: Link correction entries via `correlation_id` or metadata in `reconciliation_run_id`
- **Note**: `revenue_ledger` does not have `correlation_id` column (only `attribution_events` has it)

**Empirical Finding**: **No standardized correction fields exist** in `revenue_ledger` schema. Documentation suggests using `correlation_id` or `reconciliation_run_id`, but `correlation_id` is not present in the table.

---

#### Q3.8: Reconciliation Routines

**Question**: Are there any explicit reconciliation routines or scripts (even if not fully automated) that you've already written that rely on specific ledger semantics (e.g., assuming immutability, assuming certain status flags)?

**Answer**:

**Methodology**: Searched for reconciliation scripts, routines, or automation.

**Result**: **NO RECONCILIATION ROUTINES FOUND**

**Related Objects**:
- **Table**: `reconciliation_runs` (exists, tracks run status)
- **Materialized View**: `mv_reconciliation_status` (exists, aggregates status)
- **No Scripts**: No reconciliation automation scripts found

**Empirical Finding**: No reconciliation routines exist. The schema supports reconciliation (via `reconciliation_runs` table), but no automation is implemented.

---

### D. Channel Taxonomy & Allocations

#### Q4.1: Canonical Taxonomy Table

**Question**: Which table(s) currently act as the **canonical channel taxonomy** (e.g., `channel_taxonomy`, `marketing_channels`, `channel_types`)?

**Answer**:

**Methodology**: Searched all migration files for taxonomy, channel, or marketing channel tables.

**Result**: **NO TAXONOMY TABLE EXISTS**

**Documentation Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2, lines 832-880)
- **Specified Table**: `channel_taxonomy`
- **Status**: "✅ **DOCUMENTED** (Phase 3.2 complete)" but **NOT IMPLEMENTED**

**Current State**: `attribution_allocations.channel` uses a CHECK constraint with hardcoded values (per Question 6).

**Empirical Finding**: **No canonical taxonomy table exists**. The specification mandates `channel_taxonomy`, but it is not implemented.

---

#### Q4.2: Taxonomy Table Structure

**Question**: In the migrations, does this table have:
- A stable primary key (e.g., `channel_code`) that is intended to be used as the FK?
- Any check constraints or enumerations that imply canonical status?

**Answer**:

**Result**: **TABLE DOES NOT EXIST** (per Q4.1)

**Specification Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2, lines 839-847)
- **Specified PK**: `code text PRIMARY KEY`
- **Intended FK**: `attribution_allocations.channel_code` → `channel_taxonomy.code`

**Empirical Finding**: Cannot answer empirically because the table does not exist. Specification defines `code text PRIMARY KEY` as the intended FK target.

---

#### Q4.3: Event Channel Storage

**Question**: In `attribution_events`, how is the channel stored right now:
- Free-text (e.g., `channel` VARCHAR)?
- Enum type?
- FK to a taxonomy table?

**Answer**:

**Schema Review**: `alembic/versions/202511131115_add_core_tables.py` (lines 99-152)

**Result**: **NO CHANNEL COLUMN EXISTS**

**Columns in `attribution_events`**:
- `id`, `tenant_id`, `created_at`, `updated_at`, `occurred_at`, `external_event_id`, `correlation_id`, `session_id`, `revenue_cents`, `raw_payload`

**Empirical Finding**: `attribution_events` does **not store channel information**. Channel is only stored in `attribution_allocations.channel` (per Question 6).

---

#### Q4.4: Allocation Channel Storage

**Question**: In any allocation/attribution result tables (e.g., `attribution_allocations` or equivalent), how is channel stored and linked?

**Answer**:

**Schema Review**: `alembic/versions/202511131115_add_core_tables.py` (lines 193-236)

**Column**: `channel text NOT NULL` (line 200)

**Enhancement**: `alembic/versions/202511131232_enhance_allocation_schema.py` (lines 78-92)

**CHECK Constraint**: `ck_attribution_allocations_channel_code_valid` with hardcoded values:
- `'google_search'`, `'facebook_ads'`, `'direct'`, `'email'`, `'organic'`, `'referral'`, `'social'`, `'paid_search'`, `'display'`

**Empirical Finding**: Channel is stored as `text NOT NULL` with a CHECK constraint (hardcoded enum). No FK to taxonomy table exists.

---

#### Q4.5: Channel Value Divergences

**Question**: Are there any **known divergences** where events use one set of channel values and allocations or reports expect another (e.g., different casing, naming, or grouping)?

**Answer**:

**Methodology**: Compared channel values across tables and documentation.

**Findings**:
1. **`attribution_events`**: No channel column (per Q4.3)
2. **`attribution_allocations`**: CHECK constraint with 9 hardcoded values (per Q4.4)
3. **`channel_mapping.yaml`**: Maps vendor indicators to canonical codes (per Question 8)

**Potential Divergence**:
- **CHECK Constraint Values**: `'google_search'`, `'facebook_ads'`, `'direct'`, `'email'`, `'organic'`, `'referral'`, `'social'`, `'paid_search'`, `'display'`
- **Mapping File Values**: `facebook_paid`, `facebook_brand`, `google_search_paid`, `google_display_paid`, `tiktok_paid`, `direct`, `organic`, `referral`, `email`

**Empirical Finding**: **Divergence exists**:
- CHECK constraint uses values like `'google_search'`, `'facebook_ads'`
- Mapping file uses values like `google_search_paid`, `facebook_paid`
- No alignment between CHECK constraint and mapping file

---

#### Q4.6: Mapping and Normalization Logic

**Question**: Is there any **code-level mapping layer** (e.g., functions, services) that takes raw channels from integrations and normalizes them into the canonical taxonomy?
- If yes, where is that implemented (which module/service)?

**Answer**:

**Methodology**: Searched for mapping functions, normalization services, or channel transformation code.

**Result**: **NO MAPPING CODE EXISTS**

**Mapping File**: `db/channel_mapping.yaml` exists (per Question 8), but no code reads it.

**Empirical Finding**: **No code-level mapping layer exists**. The mapping file is ready, but no implementation reads or uses it.

---

#### Q4.7: Channel Rollup Rules

**Question**: Have you already encoded any **business rules** about how channels should roll up (e.g., sub-channels → parent channels)? If yes, are those rules implemented:
- In SQL views?
- In application code?
- Or just in documentation/notes?

**Answer**:

**Methodology**: Searched for rollup logic, parent/child channel relationships, or aggregation rules.

**Result**: **NO ROLLUP RULES FOUND**

**Specification Reference**:
- **File**: `B0.3_IMPLEMENTATION_COMPLETE.md` (Phase 3.2, lines 856-857)
- **Specified Field**: `family text NOT NULL` in `channel_taxonomy` table (for "normalized family grouping")
- **Status**: Specified but not implemented (table doesn't exist)

**Empirical Finding**: **No rollup rules implemented**. Specification defines `family` field for grouping, but the taxonomy table doesn't exist.

---

#### Q4.8: Historical Data Migration

**Question**: Are there any existing event or allocation records that you know **would not cleanly map** into a strict FK-based channel taxonomy (e.g., legacy or malformed channel strings)?

**Answer**:

**Methodology**: Cannot query database (static analysis only). Reviewed schema constraints.

**Current Constraint**: `ck_attribution_allocations_channel_code_valid` (CHECK constraint) enforces:
- `'google_search'`, `'facebook_ads'`, `'direct'`, `'email'`, `'organic'`, `'referral'`, `'social'`, `'paid_search'`, `'display'`

**Empirical Finding**: **Cannot determine from static analysis**. The CHECK constraint would reject any values outside the 9 allowed values, so existing data should be constrained. However, without database access, cannot confirm if legacy data exists.

---

#### Q4.9: Workaround Strategies

**Question**: If yes, have you already brainstormed or implemented any workaround strategies (e.g., "unknown/legacy" channel bucket, one-off mappings)?

**Answer**:

**Methodology**: Searched for workaround strategies, legacy handling, or unknown channel patterns.

**Result**: **NO WORKAROUND STRATEGIES FOUND**

**Empirical Finding**: No workaround strategies documented or implemented. The CHECK constraint would reject unknown values, suggesting no legacy handling exists.

---

### E. Roles, RLS, and Security Model

#### Q5.1: Role Model

**Question**: What is the current **role model** for DB access (e.g., `app_rw`, `app_ro`, `admin`, per-tenant roles)?

**Answer**:

**Documentation**: `db/docs/ROLES_AND_GRANTS.md` (lines 6-58)

**Roles Defined**:

1. **`app_rw`** (Read-Write Application Role):
   - Purpose: Read-write access for application (tenant-scoped queries)
   - Capabilities: SELECT, INSERT, UPDATE, DELETE on tenant-scoped tables
   - Usage: Application service connections for normal operations

2. **`app_ro`** (Read-Only Application Role):
   - Purpose: Read-only access for application (reporting, analytics)
   - Capabilities: SELECT on tenant-scoped tables
   - Usage: Read-only service connections

3. **`app_admin`** (Administrative Operations Role):
   - Purpose: Administrative operations (limited)
   - Capabilities: SELECT, INSERT, UPDATE, DELETE on administrative tables
   - Usage: Administrative service connections

4. **`migration_owner`** (Migration Execution Role):
   - Purpose: Migration execution (superuser or equivalent)
   - Capabilities: Full database access for migration execution
   - Usage: Alembic migration execution

**Empirical Finding**: Four roles are documented. `app_rw` and `app_ro` are granted privileges in migrations. `app_admin` and `migration_owner` are documented but not explicitly granted in migrations (migration_owner is implicit).

---

#### Q5.2: Production Roles

**Question**: Which roles are actually used by the application in production-like environments (not just defined)?

**Answer**:

**Methodology**: Cannot determine from static analysis (no application code, no deployment configs).

**GRANTs Applied**: `alembic/versions/202511131121_add_grants.py`
- `app_rw`: Granted on all tenant-scoped tables
- `app_ro`: Granted on all tenant-scoped tables

**Empirical Finding**: **Cannot determine empirically**. Only `app_rw` and `app_ro` have GRANTs applied, suggesting these are the intended production roles.

---

#### Q5.3: RLS Enabled Tables

**Question**: On which tables is RLS currently enabled (for real, not just planned)?

**Answer**:

**Migration**: `alembic/versions/202511131120_add_rls_policies.py`

**Tables with RLS Enabled** (lines 38-45, 59-77):
1. `attribution_events`
2. `dead_events`
3. `attribution_allocations`
4. `revenue_ledger`
5. `reconciliation_runs`

**RLS Configuration** (lines 60-64):
- `ENABLE ROW LEVEL SECURITY`
- `FORCE ROW LEVEL SECURITY` (prevents bypass)

**Policy** (lines 67-71):
- `tenant_isolation_policy` using `current_setting('app.current_tenant_id')::uuid`

**Empirical Finding**: RLS is enabled and forced on all 5 tenant-scoped tables.

---

#### Q5.4: RLS Policy for Events and Ledger

**Question**: For `attribution_events` and `revenue_ledger`, what is the **intended RLS policy** (e.g., tenant isolation) and where is it implemented (SQL files, migration scripts)?

**Answer**:

**Migration**: `alembic/versions/202511131120_add_rls_policies.py`

**Policy Name**: `tenant_isolation_policy`

**Policy Definition** (lines 67-71):
```sql
CREATE POLICY tenant_isolation_policy ON {table_name}
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid)
    WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::uuid)
```

**Applied To**:
- `attribution_events` (via loop, `table_name = 'attribution_events'`)
- `revenue_ledger` (via loop, `table_name = 'revenue_ledger'`)

**GUC Contract**: Application must set tenant context via:
```sql
set_config('app.current_tenant_id', tenant_id::text, false)
```

**Empirical Finding**: RLS policy enforces tenant isolation via `current_setting('app.current_tenant_id')::uuid` for both tables.

---

#### Q5.5: RLS vs. Immutability Tension

**Question**: From your perspective, is there any **tension or conflict** between RLS policies and immutability enforcement (e.g., policies that implicitly allow operations you intend to block)?

**Answer**:

**RLS Policy**: `tenant_isolation_policy` filters rows by `tenant_id`, but does not restrict operations (SELECT, INSERT, UPDATE, DELETE are all allowed if tenant matches).

**Immutability Policy**: Mandates no UPDATE/DELETE for application roles.

**Analysis**:
- RLS does not prevent UPDATE/DELETE operations
- RLS only filters which rows are visible/modifiable (tenant-scoped)
- RLS and immutability are orthogonal concerns

**Empirical Finding**: **No direct conflict**, but RLS does not enforce immutability. RLS ensures tenant isolation, but does not prevent UPDATE/DELETE operations that immutability policy forbids.

---

#### Q5.6: RLS Practical Issues

**Question**: Have you encountered any **practical issues** where RLS made it harder to enforce or test immutability or channel constraints?

**Answer**:

**Methodology**: Cannot determine from static analysis (no test results, no incident reports).

**Test Scripts**: `db/tests/test_rls_isolation.sql` exists but marked as "pending execution" in `B0.3_IMPLEMENTATION_COMPLETE.md`.

**Empirical Finding**: **Cannot determine empirically**. Test scripts exist but have not been executed, so no practical issues are documented.

---

### F. Migrations, Environments, and Drift

#### Q6.1: Migration History and Refactors

**Question**: Has the `attribution_events` or `revenue_ledger` schema undergone any **significant refactors** (renames, column type changes, table splits) after the initial B0.x design? If yes, briefly describe the most impactful ones.

**Answer**:

**`attribution_events`**:
- **Initial**: `202511131115_add_core_tables.py` (creation)
- **Subsequent**: No schema changes found

**`revenue_ledger`**:
- **Initial**: `202511131115_add_core_tables.py` (creation)
- **Enhancement**: `202511131250_enhance_revenue_ledger.py` (added `allocation_id`, `posted_at`)

**Empirical Finding**: **No significant refactors**. `revenue_ledger` had one enhancement migration (added columns), but no renames, type changes, or splits.

---

#### Q6.2: Dangerous Migrations

**Question**: Are there any migrations that you consider **dangerous or fragile** (e.g., data backfills, transformations) that you've mentally flagged as "don't touch unless necessary"?

**Answer**:

**Migration Review**:

1. **`202511131115_add_core_tables.py`**: Creates all core tables (safe, initial creation)
2. **`202511131119_add_materialized_views.py`**: Creates MVs (safe)
3. **`202511131120_add_rls_policies.py`**: Enables RLS (safe, but could break if GUC not set)
4. **`202511131121_add_grants.py`**: Applies GRANTs (safe)
5. **`202511131232_enhance_allocation_schema.py`**: Adds columns with defaults (safe)
6. **`202511131240_add_sum_equality_validation.py`**: Adds trigger (could fail if data violates invariant)
7. **`202511131250_enhance_revenue_ledger.py`**: Adds nullable columns (safe)

**Potential Risk**: `202511131240_add_sum_equality_validation.py` adds a trigger that validates sum-equality. If existing data violates the invariant, the trigger could cause failures.

**Empirical Finding**: **No explicitly dangerous migrations identified**, but sum-equality validation trigger could fail if data is inconsistent.

---

#### Q6.3: Environment Differences

**Question**: Are there any **known differences** between local/dev/staging/prod schemas (e.g., migrations never run in one env, manual hotfixes in prod, out-of-band DDL)?

**Answer**:

**Methodology**: Cannot determine from static analysis (no environment configs, no deployment records).

**Empirical Finding**: **Cannot determine empirically**. No environment-specific configuration or documentation found.

---

#### Q6.4: Manual SQL

**Question**: Have you ever had to run **manual SQL** in a non-local environment that isn't captured in migrations (e.g., quick fixes, hot patches)?

**Answer**:

**Methodology**: Cannot determine from static analysis (no incident logs, no manual SQL scripts).

**Empirical Finding**: **Cannot determine empirically**. No evidence of manual SQL in repository.

---

#### Q6.5: Seed Data

**Question**: Is there any **seed data** or fixtures that effectively act as part of the B0.3 contract (e.g., default channels, default tenants)? If yes, where is that defined?

**Answer**:

**Methodology**: Searched for seed data, fixtures, or initial data scripts.

**Seed Directory**: `db/seeds/` exists but contains only `templates/seed_template.sql.template`

**Result**: **NO SEED DATA FOUND**

**Empirical Finding**: **No seed data exists**. The seed directory has a template but no actual seed files.

---

#### Q6.6: Implicit Seed Data Dependencies

**Question**: Have you seen tests or app code that implicitly rely on seed data that is *not* clearly documented as part of the contract?

**Answer**:

**Methodology**: Cannot determine (no application code, tests marked as "pending execution").

**Empirical Finding**: **Cannot determine empirically**. No application code or executed tests to analyze.

---

### G. Tests, QA, and Prior Evidence

#### Q7.1: Current Automated Tests

**Question**: What automated tests (unit/integration) currently exist that:
- Assert event immutability?
- Assert ledger immutability?
- Assert channel taxonomy consistency?

**Answer**:

**Test Scripts Found**:

1. **`db/tests/test_events_append_only.sql`**:
   - **Purpose**: Test events append-only behavior
   - **Status**: Created but "pending execution" (per `B0.3_IMPLEMENTATION_COMPLETE.md`)

2. **`db/tests/test_rls_isolation.sql`**:
   - **Purpose**: Test RLS tenant isolation
   - **Status**: Created but "pending execution"

3. **`db/tests/test_contract_compliance.sql`**:
   - **Purpose**: Test materialized view JSON compliance
   - **Status**: Created but "pending execution"

4. **`db/tests/test_foreign_keys.sql`**:
   - **Purpose**: Test foreign key constraints
   - **Status**: Created but "pending execution"

5. **`db/tests/test_sum_equality.sql`**:
   - **Purpose**: Test sum-equality validation
   - **Status**: Created but "pending execution"

**Empirical Finding**: **Test scripts exist but have not been executed**. No evidence of immutability or channel taxonomy tests being run.

---

#### Q7.2: Trusted Tests

**Question**: Where are these tests located in the repo, and which ones do you trust as **reflecting the intended contract** vs. just incidental behavior?

**Answer**:

**Test Location**: `db/tests/`

**Test Files**:
- `test_events_append_only.sql` - Intended contract (immutability)
- `test_rls_isolation.sql` - Intended contract (tenant isolation)
- `test_contract_compliance.sql` - Intended contract (API compliance)
- `test_foreign_keys.sql` - Intended contract (referential integrity)
- `test_sum_equality.sql` - Intended contract (revenue accounting)

**Empirical Finding**: **All tests appear to reflect intended contract**, but none have been executed, so trust cannot be validated.

---

#### Q7.3: Testing Gaps

**Question**: From your perspective, where are the **biggest testing gaps** relative to the three invariants (events, ledger, channels)?

**Answer**:

**Three Invariants**:

1. **Event Immutability**:
   - **Test**: `test_events_append_only.sql` exists
   - **Gap**: Not executed, and no test for guard triggers (which don't exist)

2. **Ledger Immutability**:
   - **Test**: No dedicated test found
   - **Gap**: No test for ledger immutability or guard triggers

3. **Channel Taxonomy Consistency**:
   - **Test**: No dedicated test found
   - **Gap**: No test for FK to taxonomy table (which doesn't exist)

**Empirical Finding**: **Biggest gaps**:
1. Ledger immutability tests (none exist)
2. Channel taxonomy tests (none exist)
3. Guard trigger tests (triggers don't exist, so tests can't exist)

---

#### Q7.4: Documented Missing Tests

**Question**: Have you already documented any known missing tests that you planned to add but haven't yet?

**Answer**:

**Methodology**: Searched for TODO comments, missing test documentation, or test plans.

**Result**: **NO DOCUMENTED MISSING TESTS FOUND**

**Empirical Finding**: No explicit documentation of missing tests, but gaps are evident from test file inventory.

---

#### Q7.5: Historical Bugs and Incidents

**Question**: Have you encountered any bugs or incidents that were directly caused by:
- Event mutability?
- Ledger mutability or corrections?
- Channel inconsistency/taxonomy issues?

**Answer**:

**Methodology**: Cannot determine from static analysis (no incident logs, no bug reports).

**Empirical Finding**: **Cannot determine empirically**. No incident logs or bug reports found in repository.

---

#### Q7.6: Failure Mode Examples

**Question**: If yes, briefly describe one or two that you think best illustrate the current failure modes.

**Answer**:

**Result**: **NO INCIDENTS DOCUMENTED**

**Empirical Finding**: Cannot provide examples (no incidents documented).

---

### H. Known Blockers and Assessment

#### Q8.1: Single Biggest Blocker

**Question**: In your own words, what do you believe is the **single biggest reason** B0.3 cannot currently be declared "closed"?

**Answer**:

**Single Biggest Blocker**: **Gap between specification and implementation**

**Evidence**:
1. **Immutability**: Policy mandates immutability, but GRANTs allow UPDATE/DELETE
2. **Guard Triggers**: Specified but not implemented
3. **Channel Taxonomy**: Specified but not implemented (CHECK constraint used instead)

**Root Cause**: B0.3 has comprehensive specifications but incomplete implementation. The "mixed state" is defined by strong design policy (documented) and partial database enforcement (migrations grant mutation privileges, lack guard triggers, use CHECK instead of FK).

**Empirical Finding**: The single biggest blocker is the **implementation gap**: specifications are complete, but critical enforcement mechanisms (GRANT revocation, guard triggers, taxonomy table) are missing.

---

#### Q8.2: Top 3 Concrete Blockers

**Question**: If you had to name the **top 3 concrete blockers** (code-level, schema-level, or documentation-level) that must be resolved before you'd personally sign off B0.3 as "empirically closed," what are they?

**Answer**:

**Top 3 Concrete Blockers**:

1. **Immutability Enforcement Gap (Schema-Level)**:
   - **Issue**: `app_rw` has UPDATE/DELETE on `attribution_events` and `revenue_ledger`
   - **Required**: REVOKE UPDATE, DELETE from `app_rw` on both tables
   - **Evidence**: `202511131121_add_grants.py:71` grants full CRUD

2. **Defense-in-Depth Gap (Schema-Level)**:
   - **Issue**: Guard triggers (`fn_events_prevent_mutation`, `fn_ledger_prevent_mutation`) are specified but not implemented
   - **Required**: Create trigger functions and triggers on both tables
   - **Evidence**: No migration creates these triggers (searches returned no matches)

3. **Channel Taxonomy Gap (Schema-Level)**:
   - **Issue**: `attribution_allocations` uses CHECK constraint instead of FK to `channel_taxonomy` table
   - **Required**: Create `channel_taxonomy` table, drop CHECK constraint, add FK
   - **Evidence**: `202511131232_enhance_allocation_schema.py:78-92` uses CHECK constraint; no `channel_taxonomy` table exists

**Empirical Finding**: All three blockers are **schema-level implementation gaps** where specifications exist but migrations are missing.

---

#### Q8.3: Preferred Remediation Ordering

**Question**: Do you already have a **preferred sequence** for fixing these issues (e.g., "fix events immutability first, then ledger, then channels," or some other order)?

**Answer**:

**Recommended Sequence** (based on dependencies and risk):

1. **Phase 1: Events Immutability** (Lowest risk, no dependencies):
   - REVOKE UPDATE, DELETE from `app_rw` on `attribution_events`
   - Create `fn_events_prevent_mutation()` and `trg_events_prevent_mutation`
   - **Rationale**: Events are foundational; fixing first establishes pattern

2. **Phase 2: Ledger Immutability** (Medium risk, depends on events):
   - REVOKE UPDATE, DELETE from `app_rw` on `revenue_ledger`
   - Create `fn_ledger_prevent_mutation()` and `trg_ledger_prevent_mutation`
   - **Rationale**: Ledger depends on events; fix after events

3. **Phase 3: Channel Taxonomy** (Highest risk, requires data migration):
   - Create `channel_taxonomy` table
   - Populate with canonical codes
   - Drop CHECK constraint on `attribution_allocations.channel`
   - Add FK constraint
   - **Rationale**: Requires data migration; do last to minimize risk

**Empirical Finding**: Sequential ordering recommended: Events → Ledger → Channels (based on dependency and risk).

---

#### Q8.4: Dangerous Remediation Paths

**Question**: Are there any remediation paths you consider **dangerous or high-risk** (e.g., ones that might break existing data or require heavy backfills)?

**Answer**:

**High-Risk Remediation Paths**:

1. **Channel Taxonomy Migration** (Highest Risk):
   - **Risk**: Requires data migration if existing `attribution_allocations` rows have channel values
   - **Risk**: CHECK constraint to FK migration could fail if data doesn't match taxonomy
   - **Mitigation**: Validate all existing channel values before migration

2. **Ledger Immutability (if data exists)** (Medium Risk):
   - **Risk**: If `revenue_ledger` has rows that were updated/deleted, revoking privileges could break existing workflows
   - **Mitigation**: Audit existing data for UPDATE/DELETE patterns before revoking

3. **Guard Triggers** (Low Risk):
   - **Risk**: Triggers could fail if existing data violates immutability assumptions
   - **Mitigation**: Test triggers on staging before production

**Empirical Finding**: **Channel taxonomy migration is highest risk** due to data migration requirements. Events and ledger immutability are lower risk if no existing mutation workflows exist.

---

## Summary of Empirical Findings

### Confirmed Gaps

1. **Immutability Gap**: `app_rw` has UPDATE/DELETE on `attribution_events` and `revenue_ledger`
2. **Defense-in-Depth Gap**: Guard triggers are specified but not implemented
3. **Taxonomy Gap**: `channel_taxonomy` table does not exist; CHECK constraint used instead

### Implementation Status

- **Specifications**: ✅ Complete and comprehensive
- **Migrations**: ⚠️ Partial (core tables exist, but enforcement mechanisms missing)
- **Application Code**: ❌ None exists
- **Tests**: ⏳ Scripts created but not executed

### Recommended Remediation Sequence

1. Events immutability (REVOKE + triggers)
2. Ledger immutability (REVOKE + triggers)
3. Channel taxonomy (table creation + FK migration)

---

**Document Status**: ✅ **COMPLETE**  
**Analysis Methodology**: Static code analysis, migration review, documentation inspection  
**Confidence Level**: High (all answers grounded in empirical evidence from codebase)


